<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alien Computer: Retro Sci-Fi Dashboard Terminal Emulator</title>

    <meta name="description" content="Experience an interactive, randomized retro sci-fi dashboard with an alien aesthetic, 50 panel types, 50 'Tetris-like' static layouts filling the entire browser window, with significantly improved performance and robustly filled glyph-only content.">
    <meta name="keywords" content="retro, sci-fi, dashboard, alien, interactive, crt, generative, procedural, interface, computer screen, tetris layout, 50 panels, 50 layouts, static display, glyphs only, full panels, no overlap, optimized, performance, revamped">
    <meta name="author" content="Chris Pirillo">
    <meta property="og:title" content="Alien Computer: Retro Sci-Fi Dashboard Terminal Emulator">
    <meta property="og:description" content="Interactive, randomized retro sci-fi dashboard with 50 panel types, 50 'Tetris-like' static layouts filling the entire browser window, with significantly improved performance and robustly filled glyph-only content.">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://pirillo.com/arcade/images/alien-computer.png">
    <meta property="og:url" content="https://pirillo.com/arcade/alien-computer.html">
    <meta property="og:image:alt" content="A retro sci-fi computer dashboard with alien glyphs, 50 panel types and varied panel sizes in a static layout, using only glyphs, with robustly filled content and optimized performance.">

	<link rel="canonical" href="https://pirillo.com/arcade/alien-computer.html">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Alien Computer: Retro Sci-Fi Dashboard Terminal Emulator">
    <meta name="twitter:description" content="Interactive, randomized retro sci-fi dashboard with 50 panel types, 50 static layouts, and optimized performance.">
    <meta name="twitter:image" content="https://pirillo.com/arcade/images/alien-computer.png">

    <meta name="theme-color" content="#000000">

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Alien Computer: Retro Sci-Fi Dashboard Terminal Emulator",
      "description": "Experience an interactive, randomized retro sci-fi dashboard with an alien aesthetic, 50 panel types, 50 complex 'Tetris-like' static layouts filling the entire browser window, with optimized performance and robustly filled glyph-only content.",
      "applicationCategory": "Entertainment",
      "operatingSystem": "Any (Web Browser)",
      "browserRequirements": "Requires HTML5, CSS3, and JavaScript.",
      "image": "https://pirillo.com/arcade/images/alien-computer.png",
      "url": "https://pirillo.com/arcade/alien-computer.html",      
      "keywords": "retro, sci-fi, dashboard, alien, interactive, crt, generative, interface, tetris layout, 50 panels, static, glyphs only, full content, no overlap, optimized, performance, revamped",
      "author": {
        "@type": "Organization",
        "name": "AI Enhanced"
      },
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
    </script>

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&display=swap');

        :root {
            --base-phosphor-color: #FFB000; /* Default Amber */
            --base-phosphor-color-rgb: 255,176,0;
            --primary-text-color: var(--base-phosphor-color);
            --panel-border-color: rgba(var(--base-phosphor-color-rgb), 0.4);
            --panel-title-color: rgba(var(--base-phosphor-color-rgb), 0.9);
            --panel-title-border-color: rgba(var(--base-phosphor-color-rgb), 0.25);
            --panel-glow-color-strong: rgba(var(--base-phosphor-color-rgb), 0.5);
            --panel-glow-color-subtle: rgba(var(--base-phosphor-color-rgb), 0.15);
            --main-container-border-color: rgba(var(--base-phosphor-color-rgb), 0.3);
            --main-container-glow-color: rgba(var(--base-phosphor-color-rgb), 0.25);
            
            --alert-text-color: var(--base-phosphor-color);
            --alert-border-color: rgba(var(--base-phosphor-color-rgb), 0.5);
            --alert-title-border-color: rgba(var(--base-phosphor-color-rgb), 0.35);
            --alert-glow-color: rgba(var(--base-phosphor-color-rgb), 0.7);

            --status-dot-active-color: var(--base-phosphor-color);
            --status-dot-off-bg: rgba(var(--base-phosphor-color-rgb), 0.1);
            --status-dot-off-shadow: rgba(var(--base-phosphor-color-rgb), 0.05);

            --button-active-bg: rgba(var(--base-phosphor-color-rgb), 0.4);
            --button-active-shadow: var(--primary-text-color);
            --button-default-bg: rgba(var(--base-phosphor-color-rgb), 0.1);
            --button-default-border: rgba(var(--base-phosphor-color-rgb), 0.3);
        }

        html, body {
            height: 100%; 
            margin: 0;
            padding: 0; 
            overflow: hidden; 
        }

        body {
            font-family: 'Roboto Mono', monospace, sans-serif; background-color: #000000;
            color: var(--primary-text-color); display: flex; justify-content: center;
            align-items: center; 
        }

        #dashboardRoot {
            width: 100vw; 
            height: 100vh; 
            background-color: #020202;
            border: 1px solid var(--main-container-border-color);
            border-radius: 0; 
            box-shadow: 0 0 20px var(--main-container-glow-color), inset 0 0 10px rgba(0,0,0,0.7);
            display: grid;
            gap: 2px; 
            padding: 2px; 
            overflow: hidden; position: relative;
            filter: blur(0.2px); 
            visibility: hidden; /* MODIFICATION: Initially hide to prevent FOUC */
        }
        #dashboardRoot::before { 
            content: ""; position: absolute; top: 0; left: 0; right:0; bottom:0;
            background-image:
                repeating-linear-gradient(
                    transparent 0px,
                    rgba(var(--base-phosphor-color-rgb), 0.08) 1px,
                    rgba(var(--base-phosphor-color-rgb), 0.15) 2px,
                    rgba(var(--base-phosphor-color-rgb), 0.08) 3px,
                    transparent 4px
                ),
                radial-gradient(ellipse at center, rgba(0,0,0,0) 65%, rgba(0,0,0,0.3) 100%);
            pointer-events: none; z-index: 10;
            border-radius: 0; 
            opacity: 0.95;
            animation: crtFlicker 0.12s infinite alternate;
        }
        @keyframes crtFlicker {
            0% { opacity: 0.90; }
            100% { opacity: 0.95; }
        }
        .panel {
            background-color: #000000; border: 1px solid var(--panel-border-color);
            border-radius: 3px; 
            padding: 4px 6px; 
            overflow: hidden;
            box-shadow: inset 0 0 6px var(--panel-glow-color-subtle);
            display: flex; flex-direction: column;
            min-width: 0; min-height: 0;
        }
        .panel-title {
            font-size: 0.7rem; 
            font-weight: 500; color: var(--panel-title-color);
            margin-bottom: 3px; border-bottom: 1px solid var(--panel-title-border-color);
            padding-bottom: 2px; text-shadow: 0 0 3px var(--panel-glow-color-strong);
            line-height: 1.2; display: flex; flex-wrap: wrap;
            align-items: center; gap: 1px;
            min-height: 1.3em; flex-shrink: 0;
            overflow: hidden;
        }
        .panel.alert-type { background-color: rgba(var(--base-phosphor-color-rgb), 0.05); border-color: var(--alert-border-color); }
        .panel.alert-type .panel-title { color: var(--alert-text-color); border-bottom-color: var(--alert-title-border-color); }
        .panel.alert-type .panel-title .alien-glyph, .panel.alert-type .alert-message-content .alien-glyph { color: var(--alert-text-color); }

        .main-display-canvas, .waveform-canvas, .gauge-canvas, .heatmap-canvas, .circlegraph-canvas, .wireframe-canvas, .scanner-canvas,
        .orbital-path-canvas, .frequency-spectrum-canvas, .energy-flow-canvas, .targeting-reticule-canvas, .starmap-canvas, .pulse-wave-canvas,
        .network-topology-canvas, .circular-progress-canvas,
        .logarithmic-spiral-canvas, .radar-sweep-canvas, .horizontal-spectrum-canvas, 
        .globe-projection-canvas, .data-flow-chart-canvas, .particle-collision-canvas,
        .glyph-constellation-canvas, .bio-rhythm-canvas, .hex-grid-canvas, .nav-vector-canvas, .energy-core-pulse-canvas,
        .dot-matrix-canvas, .quantum-entanglement-canvas /* Added for the new panel */ { 
            width: 100%;
            flex-grow: 1;
            min-height: 40px; 
            background-color: rgba(var(--base-phosphor-color-rgb), 0.02);
            border-radius: 2px;
            margin-top: 3px;
        }

        .status-item, .nav-item-like, .diag-item, .target-item-line, .system-log-entry {
            margin-bottom: 2px; display: flex; justify-content: space-between; align-items: flex-start;
            line-height: 1.2; min-height: 1.2em; cursor: default; font-size: 0.8rem; 
        }
        .target-item-line { cursor: pointer; transition: background-color 0.2s; }
        .target-item-line:hover { background-color: rgba(var(--base-phosphor-color-rgb), 0.1); }
        .target-item-line.selected { background-color: rgba(var(--base-phosphor-color-rgb), 0.2); box-shadow: 0 0 5px var(--primary-text-color) inset; }
        .diag-item > span:first-child { cursor: pointer; }
        .diag-item > span:first-child:hover { text-shadow: 0 0 5px var(--primary-text-color); }

        .status-item > span, .nav-item-like > span, .diag-item > span, .target-item-line > span, .system-log-entry > span {
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .status-item > span:first-child, .nav-item-like > span:first-child, .diag-item > span:first-child, .target-item-line > span:first-child, .system-log-entry > span:first-child {
            color: var(--panel-title-color); flex-basis: 40%; flex-shrink: 0; display: flex; gap: 1px; align-items: center;
        }
        .status-item > span:last-child, .nav-item-like > span:last-child, .diag-item > span:last-child, .target-item-line > span:last-child, .system-log-entry > span:last-child {
            color: var(--primary-text-color); flex-basis: 58%; flex-shrink: 1; text-align: right; display: flex; justify-content: flex-end; gap: 1px;
        }
        .status-dot {
            width: 0.4em; height: 0.4em; border-radius: 50%; margin-right: 3px; display: inline-block;
            background-color: var(--status-dot-off-bg); box-shadow: 0 0 2px var(--status-dot-off-shadow);
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        .status-dot.active { background-color: var(--status-dot-active-color); box-shadow: 0 0 4px var(--status-dot-active-color), 0 0 2px var(--status-dot-active-color) inset; }

        .blinking .alien-glyph, .blinking .status-dot.active { animation: blink-svg 1s infinite; }
        .blinking-fast .alien-glyph, .blinking-fast .status-dot.active { animation: blink-svg 0.5s infinite; }
        @keyframes blink-svg { 0%, 100% { opacity: 1; } 50% { opacity: 0.25; } }

        .data-stream, .comms-log-content, .diag-list-content, .target-list-content, .code-scroll-content, .text-block-content,
        .glyph-matrix-content, .system-log-content, .data-packet-content, .security-access-content, .text-scroller-content,
        .binary-stream-content, .dna-sequence-content, 
        .data-barcode-content, .status-light-array-content, .encrypted-transmission-content, .glyph-waterfall-content { 
            line-height: 1.15; white-space: pre-wrap; overflow-y: auto; flex-grow: 1; color: var(--primary-text-color); word-break: break-all;
            font-size: 0.85rem; 
            -ms-overflow-style: none; scrollbar-width: none;
        }
        .data-stream::-webkit-scrollbar, .comms-log-content::-webkit-scrollbar, .diag-list-content::-webkit-scrollbar, .target-list-content::-webkit-scrollbar, .code-scroll-content::-webkit-scrollbar, .text-block-content::-webkit-scrollbar,
        .glyph-matrix-content::-webkit-scrollbar, .system-log-content::-webkit-scrollbar, .data-packet-content::-webkit-scrollbar, .security-access-content::-webkit-scrollbar, .text-scroller-content::-webkit-scrollbar,
        .binary-stream-content::-webkit-scrollbar, .dna-sequence-content::-webkit-scrollbar, 
        .data-barcode-content::-webkit-scrollbar, .status-light-array-content::-webkit-scrollbar, .encrypted-transmission-content::-webkit-scrollbar, .glyph-waterfall-content::-webkit-scrollbar { display: none; }

        .data-stream .alien-line, .comms-log-content .alien-line, .diag-list-content .alien-line, .target-list-content .alien-line, .code-scroll-content .alien-line, .text-block-content .alien-line,
        .system-log-content .alien-line, .data-packet-content .alien-line, .security-access-content .alien-line, .text-scroller-content .alien-line,
        .binary-stream-content .alien-line, .dna-sequence-content .alien-line, 
        .data-barcode-content .alien-line, .encrypted-transmission-content .alien-line, .glyph-waterfall-content .alien-line { display: flex; gap: 1px; margin-bottom: 0px;}
        .comms-log-content, .diag-list-content, .target-list-content, .code-scroll-content, .data-stream, .text-block-content,
        .glyph-matrix-content, .system-log-content, .data-packet-content, .security-access-content, .text-scroller-content,
        .binary-stream-content, .dna-sequence-content, 
        .data-barcode-content, .status-light-array-content, .encrypted-transmission-content, .glyph-waterfall-content { max-height: none; }


        .signal-bars-container { margin-top: 4px; display: flex; gap: 1px; align-items: flex-end; height: 100%; flex-grow:1; min-height:20px; }
        .signal-bar { width: 18%; background-color: var(--panel-title-color); transition: height 0.3s ease-out; box-shadow: 0 0 2px var(--panel-title-color);}

        .alert-message-content { font-weight: 700; text-align: center; text-shadow: 0 0 5px var(--alert-glow-color), 0 0 10px var(--alert-glow-color); animation: pulse-alert 1.5s infinite ease-in-out; line-height: 1.3; display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 2px; flex-grow: 1;}
        @keyframes pulse-alert { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.03); opacity: 0.75; } }

        .alien-glyph { width: 0.75em; height: 0.75em; display: inline-block; vertical-align: middle; fill: currentColor; }
        .panel-title .alien-glyph {width: 0.8em; height: 0.8em;}
        .numeric-readout-panel .alien-glyph { width: 1.4em; height: 1.4em; margin: 0 1px;}
        .alert-message-content .alien-glyph { width: 1.0em; height: 1.0em; }
        .text-scroller-line .alien-glyph { width: 1.3em; height: 1.3em; } 
        .binary-stream-content .alien-glyph { width: 0.7em; height: 0.7em; opacity: 0.8; margin: 0 0.5px;}
        .dna-sequence-content .alien-glyph { width: 0.8em; height: 0.8em; margin: 0 0.5px; }
        .data-barcode-strip .alien-glyph { margin: 0; } 
        .status-light-array-content .status-dot { margin: 1px; width: 0.6em; height: 0.6em; } 
        .glyph-waterfall-column .alien-glyph { display: block; margin-bottom: 1px; }


        .progress-bar-container { width: 100%; height: 0.5em; background-color: rgba(var(--base-phosphor-color-rgb), 0.1); border-radius: 2px; overflow: hidden; margin-top: 2px;}
        .progress-bar-fill { height: 100%; background-color: var(--primary-text-color); width: 0%; transition: width 0.5s ease-out; box-shadow: 0 0 3px var(--primary-text-color);}

        .button-grid, .keypad-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(30px, 1fr)); grid-auto-rows: 1fr; gap: 3px; margin-top: 4px; flex-grow: 1; align-content: stretch; height: 100%;}
        .static-button, .keypad-button {
            background-color: var(--button-default-bg); border: 1px solid var(--button-default-border);
            padding: 3px; border-radius: 2px; display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 25px; cursor: pointer; transition: background-color 0.1s, box-shadow 0.1s;
            height: 100%; 
        }
        .static-button:hover, .keypad-button:hover { background-color: rgba(var(--base-phosphor-color-rgb), 0.2); }
        .static-button.active, .keypad-button.active { background-color: var(--button-active-bg); box-shadow: 0 0 5px var(--button-active-shadow); border-color: var(--button-active-shadow); }
        .static-button .alien-glyph { width: 0.65em; height: 0.65em; }
        .keypad-button { min-height: 22px; padding: 4px; }
        .keypad-button .alien-glyph { width: 0.9em; height: 0.9em; }

        .system-tree-node { margin-left: 8px; padding-left: 8px; border-left: 1px dashed rgba(var(--base-phosphor-color-rgb), 0.3); margin-bottom: 1px;}
        .system-tree-node .alien-line { margin-bottom: 0;}
        .code-scroll-content .alien-line { font-size: 0.85em; }
        .code-scroll-content .indent-1 { padding-left: 0.8em; } .code-scroll-content .indent-2 { padding-left: 1.6em; }
        .status-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(1.5em, 1fr)); gap: 2px; flex-grow: 1; align-content: flex-start; padding-top: 5px;}
        .status-grid-cell { width: 1.2em; height: 1.2em; border: 1px solid rgba(var(--base-phosphor-color-rgb), 0.2); display: flex; justify-content: center; align-items: center;}
        .status-grid-cell .alien-glyph { width: 0.7em; height: 0.7em;}
        .text-block-content .alien-glyph { margin: 0 0.5px; }
        .sequence-scanner-content { display: flex; flex-direction: column; gap: 1px; flex-grow: 1; overflow: hidden; position:relative; }
        .sequence-scanner-line { display: flex; align-items: center; position: relative; min-height: 1.1em; }
        .scanner-bar { position: absolute; left: 0; top:0; bottom:0; background-color: rgba(var(--base-phosphor-color-rgb),0.4); animation: scan 3s linear infinite; }
        @keyframes scan { 0% { width: 0%; left: 0%;} 45% { width: 10%; left: 0%;} 50% { width: 10%; left: 90%;} 55% { width: 10%; left: 0%;} 100% { width: 0%; left: 0%;} }

        .glyph-matrix-content { display: grid; grid-template-columns: repeat(auto-fill, minmax(1em, 1fr)); gap: 2px; align-content: flex-start; padding: 2px; }
        .glyph-matrix-cell { width: 1em; height: 1em; display: flex; justify-content: center; align-items: center; }
        .glyph-matrix-cell .alien-glyph { width: 1em; height: 1em; }
        .data-packet { background-color: rgba(var(--base-phosphor-color-rgb), 0.1); border: 1px solid rgba(var(--base-phosphor-color-rgb), 0.2); border-radius: 2px; padding: 1px 3px; margin-bottom: 2px; display: inline-flex; gap: 1px; font-size: 0.9em;}
        .security-access-content { display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
        .security-status-line { margin-top: 5px; font-weight: bold; }

        .text-scroller-content { overflow: hidden; white-space: nowrap; }
        .text-scroller-line { display: inline-block; animation: scroll-text 20s linear infinite; }
        @keyframes scroll-text { 0% { transform: translateX(5%); } 100% { transform: translateX(-100%); } }

        .dna-sequence-content .dna-pair { display: inline-flex; flex-direction: column; align-items: center; margin: 0 1px; }
        .dna-sequence-content .dna-connector { width:1px; height: 5px; background-color: rgba(var(--base-phosphor-color-rgb),0.3); margin: 1px 0;}

        .data-barcode-content { display: flex; flex-direction: column; gap: 2px; }
        .data-barcode-strip { display: flex; align-items: flex-end; height: 1.2em; }
        .status-light-array-content { display: grid; grid-template-columns: repeat(auto-fill, minmax(0.8em, 1fr)); gap: 1px; align-content: flex-start; padding: 2px;}
        .glyph-waterfall-content { display: flex; justify-content: space-around; overflow: hidden; }
.glyph-waterfall-column { line-height: 1; animation: fall 5s linear infinite; }
@keyframes fall { 0% { transform: translateY(-100%); opacity: 0; } 10% { opacity: 1;} 90% { opacity: 1;} 100% { transform: translateY(100%); opacity: 0;} }

        #screenshotButton {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 2.2em;
            height: 2.2em;
            background-color: var(--button-default-bg);
            border: 1px solid var(--button-default-border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.15s;
            z-index: 1000;
        }
        #screenshotButton:hover {
            background-color: rgba(var(--base-phosphor-color-rgb), 0.2);
        }
    </style>
</head>
<body>
    <svg width="0" height="0" style="position:absolute;visibility:hidden;">
        <symbol id="g1" viewBox="0 0 10 10"><path d="M2 1 V9 M1 2 H3 M1 8 H3" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g2" viewBox="0 0 10 10"><path d="M5 1 V9 M2 5 H8" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g3" viewBox="0 0 10 10"><path d="M2 1 H8 V3 H2Z M2 7 H8 V9 H2Z M5 3 V7" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g4" viewBox="0 0 10 10"><path d="M2 1 V9 L8 5 Z" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g5" viewBox="0 0 10 10"><path d="M2 1 H8 M2 9 H8 M2 5 H5 L8 2 M8 8 L5 5" stroke="currentColor" stroke-width="1" fill="none"/></symbol> <symbol id="g6" viewBox="0 0 10 10"><path d="M5 1 V5 M1 5 H9 M5 5 V9" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g7" viewBox="0 0 10 10"><circle cx="5" cy="3" r="2" stroke="currentColor" stroke-width="1" fill="none"/><path d="M5 5 V9 M3 9 H7" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g8" viewBox="0 0 10 10"><path d="M2 1 V9 M8 1 V9 M2 5 H8" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g9" viewBox="0 0 10 10"><path d="M5 1 V9" stroke="currentColor" stroke-width="1.5" fill="none"/></symbol> <symbol id="g10" viewBox="0 0 10 10"><path d="M8 1 V9 M2 9 H8" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g11" viewBox="0 0 10 10"><path d="M2 1 V9 M2 5 L8 1 M2 5 L8 9" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g12" viewBox="0 0 10 10"><path d="M2 1 V9 H8" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g13" viewBox="0 0 10 10"><path d="M1 9 L3 1 L5 9 L7 1 L9 9" stroke="currentColor" stroke-width="1" fill="none"/></symbol> <symbol id="g14" viewBox="0 0 10 10"><path d="M2 9 L2 1 L8 9 L8 1" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g15" viewBox="0 0 10 10"><circle cx="5" cy="5" r="4" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g16" viewBox="0 0 10 10"><path d="M2 1 V9 H8 V5 H2" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g17" viewBox="0 0 10 10"><circle cx="5" cy="5" r="4" stroke="currentColor" stroke-width="1.2" fill="none"/><line x1="5" y1="5" x2="8" y2="8" stroke="currentColor" stroke-width="1"/></symbol> <symbol id="g18" viewBox="0 0 10 10"><path d="M2 1 V9 H8 V5 H5 L8 1" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g19" viewBox="0 0 10 10"><path d="M8 1 H2 V5 H8 V9 H2" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g20" viewBox="0 0 10 10"><path d="M1 1 H9 M5 1 V9" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g21" viewBox="0 0 10 10"><path d="M2 1 V7 L8 7 L8 1" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g22" viewBox="0 0 10 10"><path d="M1 1 L5 9 L9 1" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g23" viewBox="0 0 10 10"><path d="M1 1 L3 9 L5 1 L7 9 L9 1" stroke="currentColor" stroke-width="1" fill="none"/></symbol> <symbol id="g24" viewBox="0 0 10 10"><path d="M1 1 L9 9 M9 1 L1 9" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g25" viewBox="0 0 10 10"><path d="M1 1 L5 5 M9 1 L5 5 M5 5 V9" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g26" viewBox="0 0 10 10"><path d="M1 1 H9 L1 9 H9" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g27" viewBox="0 0 10 10"><path d="M3 1 V9 M7 1 V9 M1 5 H9" stroke="currentColor" stroke-width="1" fill="none"/></symbol> <symbol id="g28" viewBox="0 0 10 10"><rect x="2" y="2" width="6" height="6" stroke="currentColor" stroke-width="1" fill="none"/><circle cx="5" cy="5" r="1.5" fill="currentColor"/></symbol> <symbol id="g29" viewBox="0 0 10 10"><path d="M1 5 H5 L9 1 M1 5 H5 L9 9" stroke="currentColor" stroke-width="1.2" fill="none"/></symbol> <symbol id="g30" viewBox="0 0 10 10"><path d="M5 1 L5 3 M5 7 L5 9 M1 5 L3 5 M7 5 L9 5 M3 3 L7 3 L7 7 L3 7 Z" stroke="currentColor" stroke-width="1" fill="none"/></symbol> </svg>

    <div id="dashboardRoot">
        </div>
    <div id="screenshotButton" title="Save Screenshot">
        <svg class="alien-glyph"><use href="#g18"></use></svg>
    </div>

    <script>
        // --- Global flag to prevent concurrent dashboard builds ---
        let isBuildingDashboard = false;
        // --- Core Alien Glyph and Utility Functions ---
        const alienGlyphIds = Array.from({length: 30}, (_, i) => `g${i + 1}`);
        const binaryGlyphZero = alienGlyphIds[0];
        const binaryGlyphOne = alienGlyphIds[1];

        function createAlienGlyphSVG(glyphId) {
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("class", "alien-glyph");
            const use = document.createElementNS(svgNS, "use");
            use.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + glyphId);
            svg.appendChild(use);
            return svg;
        }

        function generateAlienSVGSequence(length, targetElement, isBlinking = false, isBlinkingFast = false) {
            if (!targetElement) return;
            targetElement.innerHTML = ''; 

            const parentFontSize = parseFloat(getComputedStyle(targetElement.parentElement || document.body).fontSize) || 16;
            let approxGlyphWidthPx = 0.75 * parentFontSize * 0.50; 

            if (targetElement.classList.contains('panel-title')) approxGlyphWidthPx = 0.8 * parentFontSize * 0.50;
            else if (targetElement.classList.contains('numeric-readout-line')) approxGlyphWidthPx = 1.4 * parentFontSize * 0.50;
            else if (targetElement.classList.contains('alert-message-content')) approxGlyphWidthPx = 1.0 * parentFontSize * 0.50;
            
            let availableWidthPx = targetElement.clientWidth;
             if (!availableWidthPx || availableWidthPx < 10) { 
                if (targetElement.parentElement) availableWidthPx = targetElement.parentElement.clientWidth * 0.80; 
                if (!availableWidthPx || availableWidthPx < 10) availableWidthPx = 80; 
            }

            const maxGlyphsPerLine = approxGlyphWidthPx > 0 ? Math.max(1, Math.floor(availableWidthPx / approxGlyphWidthPx)) : 12; 
            const finalLength = Math.min(length, maxGlyphsPerLine); 

            for (let i = 0; i < finalLength; i++) {
                let glyphIdToUse = alienGlyphIds[Math.floor(Math.random() * alienGlyphIds.length)];
                if (targetElement.classList.contains('binary-stream-content') || targetElement.classList.contains('binary-line') || targetElement.classList.contains('data-barcode-strip')) {
                    glyphIdToUse = Math.random() < 0.5 ? binaryGlyphZero : binaryGlyphOne;
                }

                const svgGlyph = createAlienGlyphSVG(glyphIdToUse);
                if (isBlinking) svgGlyph.classList.add('blinking');
                if (isBlinkingFast) svgGlyph.classList.add('blinking-fast');
                targetElement.appendChild(svgGlyph);
            }
        }

        function generateAlienSVGLine(length, parentWidth = 250, isBinary = false) {
            const lineDiv = document.createElement('div');
            lineDiv.className = 'alien-line';
            if(isBinary) lineDiv.classList.add('binary-line');

            const approxGlyphWidthPx = 0.75 * (parseFloat(getComputedStyle(document.body).fontSize) || 16) * 0.50; 
            const targetGlyphCount = Math.min(length, parentWidth > 0 && approxGlyphWidthPx > 0 ? Math.floor(parentWidth / approxGlyphWidthPx) : length);
            
            generateAlienSVGSequence(targetGlyphCount, lineDiv);
            return lineDiv;
        }
        function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }

        const dashboardRoot = document.getElementById('dashboardRoot');
        const panelUpdateIntervals = []; 
        let globalAlertPanelRef = null; 

        // --- Theme and Color Management ---
        const baseColors = [
            { name: 'amber', hex: '#FFB000', rgb: '255,176,0' }, { name: 'green', hex: '#00FF00', rgb: '0,255,0' },
            { name: 'red', hex: '#FF4444', rgb: '255,68,68' }, { name: 'blue', hex: '#55CCFF', rgb: '85,204,255' },
            { name: 'white', hex: '#FFFFFF', rgb: '255,255,255' }, { name: 'purple', hex: '#9370DB', rgb: '147,112,219' },
            { name: 'orange', hex: '#FFA500', rgb: '255,165,0' }, { name: 'pink', hex: '#FFC0CB', rgb: '255,192,203' },
            { name: 'teal', hex: '#008080', rgb: '0,128,128' }, { name: 'yellow', hex: '#FFFF00', rgb: '255,255,0' },
            { name: 'fuchsia', hex: '#FF00FF', rgb: '255,0,255' }
        ];
        function applyRandomMonochromeTheme() { const selectedBase = baseColors[Math.floor(Math.random() * baseColors.length)]; const rootStyle = document.documentElement.style; rootStyle.setProperty('--base-phosphor-color', selectedBase.hex); rootStyle.setProperty('--base-phosphor-color-rgb', selectedBase.rgb); }

        // --- Panel Utilities ---
        function createPanelShell(type = '', areaName = '') {
            const panel = document.createElement('div'); panel.className = 'panel';
            if (type) panel.classList.add(type + '-type'); if (areaName) panel.style.gridArea = areaName;
            const title = document.createElement('div'); title.className = 'panel-title'; panel.appendChild(title);
            return { panel, title };
        }
        function displayAlertMessage(glyphCount = 12, duration = 2000) { if (globalAlertPanelRef && globalAlertPanelRef.messageDiv) { const originalContent = Array.from(globalAlertPanelRef.messageDiv.childNodes); generateAlienSVGSequence(glyphCount, globalAlertPanelRef.messageDiv, true); setTimeout(() => { if (globalAlertPanelRef.messageDiv) { globalAlertPanelRef.messageDiv.innerHTML = ''; originalContent.forEach(node => globalAlertPanelRef.messageDiv.appendChild(node)); globalAlertPanelRef.updateAlert(); } }, duration); } }

        // --- Canvas Panel Initialization ---
        function initCanvasPanel(panel, canvas, drawFunction, initDataFunction) {
            let hasInitialized = false;
            
            function attemptDraw() {
                if (!panel.isConnected) {
                    if (initDataFunction && typeof canvas.clearAnimation === 'function') {
                        canvas.clearAnimation(); 
                    }
                    return;
                }
                const currentRect = canvas.getBoundingClientRect();

                if (currentRect.width > 0 && currentRect.height > 0) {
                    if (!hasInitialized || canvas.width !== currentRect.width || canvas.height !== currentRect.height) {
                        canvas.width = currentRect.width;
                        canvas.height = currentRect.height;
                        if (initDataFunction) {
                            initDataFunction(canvas.width, canvas.height, canvas); 
                        }
                        hasInitialized = true;
                        if (canvas.dataset.hasDrawnOnce) { 
                            delete canvas.dataset.hasDrawnOnce;
                        }
                    }
                    drawFunction(canvas); 
                    canvas.dataset.hasDrawnOnce = true; 
                } else {
                     requestAnimationFrame(attemptDraw); 
                }
            }

            const resizeHandler = debounce(() => {
                hasInitialized = false; 
                if (initDataFunction && typeof canvas.clearAnimation === 'function') { 
                    canvas.clearAnimation();
                }
                attemptDraw(); 
            }, 100);
            window.addEventListener('resize', resizeHandler);
            
            requestAnimationFrame(attemptDraw); 
            
            return () => { 
                window.removeEventListener('resize', resizeHandler);
                 if (initDataFunction && typeof canvas.clearAnimation === 'function') { 
                    canvas.clearAnimation();
                }
            };
        }


        // --- Panel Creation Functions ---

        // Abstract Data Grid Panel (Canvas)
        function drawAbstractDataGrid(canvasEl) {
            const ctx = canvasEl.getContext('2d');
            const w = canvasEl.width, h = canvasEl.height;
            if (w <= 0 || h <= 0) return; 

            ctx.clearRect(0, 0, w, h);
            const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
            const primaryColor = `rgb(${baseRGB})`;
            const glowColor = `rgba(${baseRGB}, 0.5)`;
            const alertColorCanvas = `rgba(${baseRGB}, 0.8)`; 

            ctx.strokeStyle = primaryColor;
            ctx.fillStyle = primaryColor;
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 3;

            const gridSizeX = Math.floor(Math.random() * (w / 30)) + 8; 
            const gridSizeY = Math.floor(Math.random() * (h / 30)) + 6;
            const cellWidth = w / gridSizeX, cellHeight = h / gridSizeY;
            ctx.lineWidth = Math.max(0.5, Math.min(w, h) * 0.001); 
            for (let i = 0; i <= gridSizeX; i++) {
                ctx.beginPath(); ctx.moveTo(i * cellWidth, 0); ctx.lineTo(i * cellWidth, h); ctx.stroke();
            }
            for (let j = 0; j <= gridSizeY; j++) {
                ctx.beginPath(); ctx.moveTo(0, j * cellHeight); ctx.lineTo(w, j * cellHeight); ctx.stroke();
            }

            const numLines = Math.floor(Math.random() * 6) + 4;
            ctx.lineWidth = Math.max(1, Math.min(w, h) * 0.002);
            for (let i = 0; i < numLines; i++) {
                ctx.beginPath(); ctx.moveTo(Math.random() * w, Math.random() * h); ctx.lineTo(Math.random() * w, Math.random() * h);
                ctx.strokeStyle = (Math.random() < 0.3 ? alertColorCanvas : primaryColor); ctx.stroke();
            }

            const numCircles = Math.floor(Math.random() * 5) + 3;
            for (let i = 0; i < numCircles; i++) {
                ctx.beginPath(); const radius = Math.random() * (Math.min(w, h) * 0.03) + (Math.min(w, h) * 0.005);
                ctx.arc(Math.random() * w, Math.random() * h, radius, 0, Math.PI * 2);
                if (Math.random() < 0.5) { 
                    ctx.fillStyle = (Math.random() < 0.3 ? `rgba(${baseRGB}, 0.6)` : `rgba(${baseRGB}, 0.3)`); ctx.fill();
                } else {
                    ctx.strokeStyle = primaryColor; ctx.lineWidth = Math.max(0.75, Math.min(w, h) * 0.0015); ctx.stroke();
                }
            }
            const numNodes = Math.floor(Math.random() * 6) + 4;
            for (let i = 0; i < numNodes; i++) {
                if (Math.floor(Date.now() / (350 + Math.random() * 250)) % 2 === 0) { 
                    ctx.beginPath(); const nodeX = Math.random() * w; const nodeY = Math.random() * h;
                    const nodeSize = Math.random() * (Math.min(w, h) * 0.005) + (Math.min(w, h) * 0.002);
                    ctx.arc(nodeX, nodeY, nodeSize, 0, Math.PI * 2);
                    ctx.fillStyle = (Math.random() < 0.4 ? alertColorCanvas : primaryColor); ctx.fill();
                }
            }
            ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; 
        }

        function createAbstractDataGridPanel(areaName) {
            const { panel } = createPanelShell('abstract-grid-main', areaName);
            const canvas = document.createElement('canvas');
            canvas.className = 'main-display-canvas'; 
            panel.appendChild(canvas);

            function drawAndLoop(canvasEl) {
                drawAbstractDataGrid(canvasEl);
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawAndLoop, null); 
            
            panelUpdateIntervals.push(setInterval(() => {
                if (panel.isConnected && Math.random() < 0.25 && canvas.getBoundingClientRect().width > 0) { 
                    drawAbstractDataGrid(canvas);
                }
            }, 1800 + Math.random() * 1200)); 
            return panel;
        }


        // Schematic Panel (Canvas with particle animation)
        function createSchematicPanel(areaName) {
            const { panel } = createPanelShell('schematic-main', areaName);
            const canvas = document.createElement('canvas');
            canvas.className = 'main-display-canvas';
            panel.appendChild(canvas);
            let animationFrameIdSchematic;
            let particles = [];
            const numParticles = 25; 

            function initParticles(w, h) {
                particles = [];
                for (let i = 0; i < numParticles; i++) {
                    particles.push({ x: Math.random() * w, y: Math.random() * h, vx: (Math.random() - 0.5) * 0.3, vy: (Math.random() - 0.5) * 0.3, size: Math.random() * 1.5 + 0.5, alpha: Math.random() * 0.5 + 0.2, life: Math.random() * 100 + 50 });
                }
            }
            canvas.clearAnimation = () => { 
                if (animationFrameIdSchematic) {
                    cancelAnimationFrame(animationFrameIdSchematic);
                    animationFrameIdSchematic = null;
                }
            };

            function drawSchematic(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdSchematic) cancelAnimationFrame(animationFrameIdSchematic); animationFrameIdSchematic = null; return; }
                const ctxEl = canvasEl.getContext('2d');
                const w = canvasEl.width, h = canvasEl.height;
                if (w <=0 || h <=0) { animationFrameIdSchematic = requestAnimationFrame(() => drawSchematic(canvasEl)); return;} 
                if(particles.length === 0 && (w > 0 && h > 0) ) initParticles(w,h); 

                ctxEl.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                const primaryColor = `rgb(${baseRGB})`;
                const glowColorStrong = `rgba(${baseRGB}, 0.5)`;
                ctxEl.strokeStyle = primaryColor; ctxEl.shadowColor = glowColorStrong; ctxEl.shadowBlur = 5;
                particles.forEach(p => {
                    ctxEl.beginPath(); ctxEl.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctxEl.fillStyle = `rgba(${baseRGB}, ${p.alpha})`; ctxEl.fill();
                    p.x += p.vx; p.y += p.vy; p.life--;
                    if (p.x < 0 || p.x > w || p.y < 0 || p.y > h || p.life <= 0) {
                        p.x = Math.random() * w; p.y = Math.random() * h;
                        p.vx = (Math.random() - 0.5) * 0.3; p.vy = (Math.random() - 0.5) * 0.3;
                        p.alpha = Math.random() * 0.5 + 0.2; p.life = Math.random() * 100 + 50;
                    }
                });
                ctxEl.lineWidth = 0.3;
                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dist = Math.hypot(particles[i].x - particles[j].x, particles[i].y - particles[j].y);
                        if (dist < Math.min(w,h) / 6) { 
                            ctxEl.beginPath(); ctxEl.moveTo(particles[i].x, particles[i].y); ctxEl.lineTo(particles[j].x, particles[j].y);
                            ctxEl.strokeStyle = `rgba(${baseRGB}, ${Math.min(particles[i].alpha, particles[j].alpha) * 0.3})`; ctxEl.stroke();
                        }
                    }
                }
                ctxEl.lineWidth = Math.max(0.8, Math.min(w,h) * 0.007); ctxEl.strokeStyle = primaryColor;
                if (Math.floor(Date.now() / 500) % 2 === 0) { ctxEl.beginPath(); ctxEl.arc(w / 2, h / 2, Math.min(w,h) * 0.03, 0, Math.PI * 2); ctxEl.stroke(); }
                ctxEl.shadowColor = 'transparent'; ctxEl.shadowBlur = 0;
                animationFrameIdSchematic = requestAnimationFrame(() => drawSchematic(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawSchematic, initParticles);
            return panel;
        }
        // Status Panel (Text-based with blinking dots)
        function createStatusPanel(areaName) { const { panel, title } = createPanelShell('status', areaName); const contentArea = document.createElement('div'); contentArea.style.flexGrow = "1"; contentArea.style.overflowY = "auto"; contentArea.style.display = "flex"; contentArea.style.flexDirection = "column"; panel.appendChild(contentArea); const initItems = () => { if (!panel.isConnected) return; if (!contentArea.clientHeight && panel.clientHeight > (title.offsetHeight + 10)) { requestAnimationFrame(initItems); return; } contentArea.innerHTML = ''; const panelContentHeight = contentArea.clientHeight; if(panelContentHeight <=0) return; const estimatedItemHeight = 18; const numItems = Math.max(1, Math.min(12, Math.floor(panelContentHeight / estimatedItemHeight))); for (let i = 0; i < numItems; i++) { const item = document.createElement('div'); item.className = 'status-item'; const label = document.createElement('span'); const dot = document.createElement('span'); dot.className = 'status-dot'; label.appendChild(dot); generateAlienSVGSequence(Math.floor(Math.random() * 7) + 10, label, false); const value = document.createElement('span'); generateAlienSVGSequence(Math.floor(Math.random() * 6) + 8, value, Math.random() < 0.35); item.appendChild(label); item.appendChild(value); contentArea.appendChild(item); const updateDot = () => { if (!panel.isConnected) return; dot.classList.remove('active', 'blinking'); if (Math.random() < 0.75) { dot.classList.add('active'); if (Math.random() < 0.35) dot.classList.add('blinking'); } }; updateDot(); panelUpdateIntervals.push(setInterval(updateDot, 3000 + Math.random() * 2000)); } }; panel.initContent = initItems; return panel; }

        // Data Stream Panel (Scrolling text lines)
        function createDataStreamPanel(areaName) {
            const { panel } = createPanelShell('datastream', areaName);
            const streamDiv = document.createElement('div');
            streamDiv.className = 'data-stream'; 
            panel.appendChild(streamDiv);
            const estimatedLineHeight = 15; 
            const maxHistoryLines = 60; 
            let initialFillDone = false;

            function attemptFill() {
                if (!panel.isConnected) return false;
                if (!streamDiv.clientWidth || !streamDiv.clientHeight) {
                    if (panel.clientHeight > 0 && panel.clientWidth > 0) { requestAnimationFrame(attemptFill); } 
                    return false;
                }
                const panelWidth = streamDiv.clientWidth;
                const visibleLines = Math.floor(streamDiv.clientHeight / estimatedLineHeight);
                const linesToInitiallyFill = Math.max(1, Math.min(visibleLines + 5, maxHistoryLines - 5)); 
                if (!initialFillDone) {
                    for(let i = 0; i < linesToInitiallyFill; i++) {
                        if (streamDiv.children.length < maxHistoryLines) {
                            streamDiv.appendChild(generateAlienSVGLine(Math.floor(Math.random() * 20) + 25, panelWidth));
                        }
                    }
                    streamDiv.scrollTop = streamDiv.scrollHeight; 
                    initialFillDone = true;
                } return true;
            }
            function updateStream() {
                if (!panel.isConnected) return;
                if (!initialFillDone) { if(!attemptFill()) return; } 
                if (!streamDiv.clientWidth) return; 
                
                const panelWidth = streamDiv.clientWidth;
                const numLinesToAdd = Math.floor(Math.random() * 2) + 1; 
                for (let k = 0; k < numLinesToAdd; k++) {
                    if (streamDiv.children.length >= maxHistoryLines) streamDiv.removeChild(streamDiv.firstChild); 
                    streamDiv.appendChild(generateAlienSVGLine(Math.floor(Math.random() * 20) + 25, panelWidth));
                }
                streamDiv.scrollTop = streamDiv.scrollHeight; 
            }
            panel.initContent = attemptFill; 
            panelUpdateIntervals.push(setInterval(updateStream, 300 + Math.random() * 150)); 
            return panel;
        }

        // Comms Log Panel (Similar to Data Stream, slower updates)
        function createCommsLogPanel(areaName) {
            const { panel } = createPanelShell('commslog', areaName);
            const logContent = document.createElement('div');
            logContent.className = 'comms-log-content';
            panel.appendChild(logContent);
            const estimatedLineHeight = 15;
            const maxHistoryLines = 40;
            let initialFillDone = false;

            function attemptFill() {
                if (!panel.isConnected) return false;
                if (!logContent.clientWidth || !logContent.clientHeight) {
                    if (panel.clientHeight > 0 && panel.clientWidth > 0) { requestAnimationFrame(attemptFill); }
                    return false;
                }
                const panelWidth = logContent.clientWidth;
                const visibleLines = Math.floor(logContent.clientHeight / estimatedLineHeight);
                const linesToInitiallyFill = Math.max(1, Math.min(visibleLines + 3, maxHistoryLines - 3));
                if (!initialFillDone) {
                    for(let i = 0; i < linesToInitiallyFill; i++) {
                        if (logContent.children.length < maxHistoryLines) {
                             logContent.appendChild(generateAlienSVGLine(Math.floor(Math.random() * 30) + 25, panelWidth));
                        }
                    }
                    logContent.scrollTop = logContent.scrollHeight; initialFillDone = true;
                } return true;
            }
            function updateLog() {
                if (!panel.isConnected) return;
                if (!initialFillDone) { if(!attemptFill()) return; }
                if (!logContent.clientWidth) return;
                const panelWidth = logContent.clientWidth;
                logContent.appendChild(generateAlienSVGLine(Math.floor(Math.random() * 30) + 25, panelWidth));
                if (logContent.children.length > maxHistoryLines) logContent.removeChild(logContent.firstChild);
                logContent.scrollTop = logContent.scrollHeight;
            }
            panel.initContent = attemptFill;
            panelUpdateIntervals.push(setInterval(updateLog, 2000 + Math.random() * 1000)); 
            return panel;
        }
        // Alert Panel (Blinking alert message)
        function createAlertPanel(areaName) { const { panel } = createPanelShell('alert', areaName); panel.classList.add('alert-type'); const messageDiv = document.createElement('div'); messageDiv.className = 'alert-message-content'; panel.appendChild(messageDiv); const updateAlert = () => { if (!panel.isConnected) return; generateAlienSVGSequence(Math.floor(Math.random() * 12) + 12, messageDiv); }; setTimeout(updateAlert,0); const intervalId = setInterval(updateAlert, 2800 + Math.random() * 2200); panelUpdateIntervals.push(intervalId); globalAlertPanelRef = { messageDiv, updateAlert, intervalId }; panel.initContent = updateAlert; return panel; }
        // Signal Bars Panel (Animated bar heights)
        function createSignalBarsPanel(areaName) { const { panel } = createPanelShell('signalbars', areaName); const barsContainer = document.createElement('div'); barsContainer.className = 'signal-bars-container'; panel.appendChild(barsContainer); const initBars = () => { if (!panel.isConnected) return; if (!barsContainer.clientWidth && panel.clientHeight > 0) { requestAnimationFrame(initBars); return; } barsContainer.innerHTML = ''; if(!barsContainer.clientWidth) return; const numBars = Math.max(2, Math.min(8, Math.floor(barsContainer.clientWidth / 12))); const bars = []; for (let i = 0; i < numBars; i++) { const bar = document.createElement('div'); bar.className = 'signal-bar'; bar.style.width = `${100/numBars - 2}%`; barsContainer.appendChild(bar); bars.push(bar); } const updateBars = () => { if (!panel.isConnected) return; bars.forEach(bar => bar.style.height = (Math.random() * 80 + 20) + '%'); }; updateBars(); panelUpdateIntervals.push(setInterval(updateBars, 650 + Math.random() * 350)); }; panel.initContent = initBars; return panel; }

        // Target List Panel (Selectable items)
        function createTargetListPanel(areaName) { const { panel, title } = createPanelShell('targetlist', areaName); const listContent = document.createElement('div'); listContent.className = 'target-list-content'; panel.appendChild(listContent); const initList = () => { if (!panel.isConnected) return; if (!listContent.clientHeight && panel.clientHeight > (title.offsetHeight + 10)) { requestAnimationFrame(initList); return; } listContent.innerHTML = ''; const panelContentHeight = listContent.clientHeight; if(panelContentHeight <=0) return; const estimatedItemHeight = 18; const numTargets = Math.max(1, Math.min(12, Math.floor(panelContentHeight / estimatedItemHeight))); for (let i = 0; i < numTargets; i++) { const item = document.createElement('div'); item.className = 'target-item-line'; const idLabel = document.createElement('span'); const dot = document.createElement('span'); dot.className = 'status-dot'; idLabel.appendChild(dot); generateAlienSVGSequence(Math.floor(Math.random()*5)+6, idLabel); const coordsValue = document.createElement('span'); generateAlienSVGSequence(Math.floor(Math.random()*8)+10, coordsValue); item.appendChild(idLabel); item.appendChild(coordsValue); listContent.appendChild(item); dot.classList.remove('active', 'blinking'); if (Math.random() < 0.8) { dot.classList.add('active'); if (Math.random() < 0.4) dot.classList.add('blinking'); } item.onclick = () => { if (!panel.isConnected) return; document.querySelectorAll('.target-item-line.selected').forEach(el => el.classList.remove('selected')); item.classList.add('selected'); dot.classList.add('blinking-fast'); setTimeout(() => dot.classList.remove('blinking-fast'), 1000); displayAlertMessage(Math.floor(Math.random()*3)+5); }; } }; panel.initContent = initList; panelUpdateIntervals.push(setInterval(initList, 5000 + Math.random() * 2000)); return panel; }
        // Diagnostics Panel (With progress bars)
        function createDiagnosticsPanel(areaName) { const { panel, title } = createPanelShell('diagnostics', areaName); const diagContent = document.createElement('div'); diagContent.className = 'diag-list-content'; panel.appendChild(diagContent); const initDiag = () => { if (!panel.isConnected) return; if (!diagContent.clientHeight && panel.clientHeight > (title.offsetHeight + 10)) { requestAnimationFrame(initDiag); return; } diagContent.innerHTML = ''; const panelContentHeight = diagContent.clientHeight; if(panelContentHeight <=0) return; const estimatedItemHeight = 25; const numSystems = Math.max(1, Math.min(10, Math.floor(panelContentHeight / estimatedItemHeight))); const systemElements = []; for (let i = 0; i < numSystems; i++) { const item = document.createElement('div'); item.className = 'diag-item'; const label = document.createElement('span'); generateAlienSVGSequence(Math.floor(Math.random()*7)+8, label); const statusValue = document.createElement('span'); const progressBarContainer = document.createElement('div'); progressBarContainer.className = 'progress-bar-container'; const progressBarFill = document.createElement('div'); progressBarFill.className = 'progress-bar-fill'; progressBarContainer.appendChild(progressBarFill); item.appendChild(label); item.appendChild(statusValue); diagContent.appendChild(item); diagContent.appendChild(progressBarContainer); systemElements.push({ item, label, statusValue, progressBarFill }); label.onclick = () => { if (!panel.isConnected) return; progressBarFill.style.width = '0%'; setTimeout(() => { generateAlienSVGSequence(Math.floor(Math.random()*5)+5, statusValue, true); progressBarFill.style.width = (Math.random() * 85 + 15) + '%'; }, 100); setTimeout(() => statusValue.classList.remove('blinking'), 1000); displayAlertMessage(Math.floor(Math.random()*2)+3); }; } const updateDiagnostics = () => { if (!panel.isConnected) return; systemElements.forEach(sys => { if (!sys.statusValue.classList.contains('blinking')) { generateAlienSVGSequence(Math.floor(Math.random()*5)+5, sys.statusValue, Math.random() < 0.15); } if (parseFloat(sys.progressBarFill.style.width) === 0) {} else { sys.progressBarFill.style.width = (Math.random() * 85 + 15) + '%'; } }); }; setTimeout(updateDiagnostics,0); panelUpdateIntervals.push(setInterval(updateDiagnostics, 3500 + Math.random() * 1000)); }; panel.initContent = initDiag; return panel; }
        // Waveform Panel (Animated line graph on canvas)
        function createWaveformPanel(areaName) {
            const { panel } = createPanelShell('waveform', areaName);
            const canvas = document.createElement('canvas');
            canvas.className = 'waveform-canvas';
            panel.appendChild(canvas);
            let animationFrameIdWave;
            const waveData = new Array(100).fill(0); 
            canvas.clearAnimation = () => { if (animationFrameIdWave) cancelAnimationFrame(animationFrameIdWave); animationFrameIdWave = null; };

            function drawWave(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdWave) cancelAnimationFrame(animationFrameIdWave); animationFrameIdWave = null; return; }
                const ctx = canvasEl.getContext('2d');
                const w = canvasEl.width, h = canvasEl.height;
                if(w <= 0 || h <= 0) {animationFrameIdWave = requestAnimationFrame(() => drawWave(canvasEl)); return;} 
                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                const primaryColor = `rgb(${baseRGB})`;
                const glowColor = `rgba(${baseRGB}, 0.4)`;
                ctx.strokeStyle = primaryColor;
                ctx.lineWidth = Math.max(1, Math.min(w,h) * 0.01); 
                ctx.shadowColor = glowColor; ctx.shadowBlur = 3;
                const newDataPoint = (Math.random() - 0.5) * (h * 0.8) + (h / 2); 
                waveData.push(newDataPoint);
                if (waveData.length > w / 2) waveData.shift(); 
                ctx.beginPath(); ctx.moveTo(0, waveData[0] || h/2);
                for (let i = 0; i < waveData.length; i++) {
                    ctx.lineTo(i * (w / (waveData.length -1 || 1) ), waveData[i]);
                }
                ctx.stroke();
                ctx.shadowColor = 'transparent'; 
                animationFrameIdWave = requestAnimationFrame(() => drawWave(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawWave, null);
            return panel;
        }
        // Numeric Readout Panel (Lines of numeric-like glyphs)
        function createNumericReadoutPanel(areaName) { const { panel, title } = createPanelShell('numeric-readout', areaName); panel.classList.add('numeric-readout-panel'); const initReadout = () => { if (!panel.isConnected) return; if (!panel.clientHeight && panel.parentElement.clientHeight > 0) { requestAnimationFrame(initReadout); return; } panel.querySelectorAll('.numeric-readout-line').forEach(l => l.remove()); const panelContentHeight = panel.clientHeight - (title.offsetHeight + 10); if (panelContentHeight <=0) return; const estimatedLineHeight = 25; const numLines = Math.max(1, Math.min(5, Math.floor(panelContentHeight / estimatedLineHeight))); const lineElements = []; for (let i = 0; i < numLines; i++) { const lineDiv = document.createElement('div'); lineDiv.className = 'numeric-readout-line'; panel.appendChild(lineDiv); lineElements.push(lineDiv); } const updateReadouts = () => { if (!panel.isConnected) return; lineElements.forEach(lineEl => { generateAlienSVGSequence(Math.floor(Math.random() * 7) + 6, lineEl, Math.random() < 0.15); }); }; setTimeout(updateReadouts,0); panelUpdateIntervals.push(setInterval(updateReadouts, 3000 + Math.random() * 1500)); }; panel.initContent = initReadout; return panel; }
        // Button/Switch Panel (Grid of clickable buttons)
        function createButtonSwitchPanel(areaName) { const { panel, title } = createPanelShell('button-switch', areaName); const grid = document.createElement('div'); grid.className = 'button-grid'; panel.appendChild(grid); const initButtons = () => { if (!panel.isConnected) return; if (!grid.clientHeight && panel.clientHeight > (title.offsetHeight + 10)) { requestAnimationFrame(initButtons); return; } grid.innerHTML = ''; const panelContentHeight = grid.clientHeight; const panelContentWidth = grid.clientWidth; if (panelContentHeight <=0 || panelContentWidth <=0) return; const buttonSize = 35; const numCols = Math.max(1, Math.floor(panelContentWidth / buttonSize)); const numRows = Math.max(1, Math.floor(panelContentHeight / buttonSize)); const numButtons = Math.min(12, numCols * numRows); for (let i = 0; i < numButtons; i++) { const button = document.createElement('div'); button.className = 'static-button'; if (Math.random() < 0.35) button.classList.add('lit'); generateAlienSVGSequence(Math.floor(Math.random()*3)+1, button); grid.appendChild(button); button.onclick = () => { if (!panel.isConnected) return; button.classList.toggle('active'); displayAlertMessage(Math.floor(Math.random()*2)+2, 800); setTimeout(() => button.classList.remove('active'), 200); }; } }; panel.initContent = initButtons; return panel; }
        // Gauge Panel (Animated radial gauge on canvas)
        function createGaugePanel(areaName) {
            const { panel } = createPanelShell('gauge', areaName);
            const canvas = document.createElement('canvas');
            canvas.className = 'gauge-canvas';
            panel.appendChild(canvas);
            let animationFrameIdGauge;
            let currentValue = Math.random(); 
            canvas.clearAnimation = () => { if (animationFrameIdGauge) cancelAnimationFrame(animationFrameIdGauge); animationFrameIdGauge = null; };

            function drawGauge(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdGauge) cancelAnimationFrame(animationFrameIdGauge); animationFrameIdGauge = null; return; }
                const ctx = canvasEl.getContext('2d');
                const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animationFrameIdGauge = requestAnimationFrame(() => drawGauge(canvasEl)); return;}
                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                const primaryColor = `rgb(${baseRGB})`; const glowColor = `rgba(${baseRGB}, 0.4)`;
                const centerX = w / 2, centerY = h * 0.65, radius = Math.min(w * 0.35, h * 0.45);
                currentValue += (Math.random() - 0.5) * 0.05; currentValue = Math.max(0, Math.min(1, currentValue));
                ctx.strokeStyle = primaryColor; ctx.shadowColor = glowColor; ctx.shadowBlur = 4;
                ctx.beginPath(); ctx.lineWidth = Math.max(2, radius * 0.15); ctx.arc(centerX, centerY, radius, Math.PI * 0.8, Math.PI * 0.2, false); ctx.stroke();
                ctx.beginPath(); ctx.lineWidth = Math.max(3, radius * 0.2); ctx.strokeStyle = `rgba(${baseRGB}, 0.8)`; 
                ctx.arc(centerX, centerY, radius, Math.PI * 0.8, Math.PI * 0.8 + (currentValue * (Math.PI * 1.4)), false); ctx.stroke();
                ctx.beginPath(); ctx.lineWidth = Math.max(1.5, radius*0.05); ctx.strokeStyle = primaryColor; ctx.moveTo(centerX, centerY);
                const angle = Math.PI * 0.8 + (currentValue * (Math.PI * 1.4));
                ctx.lineTo(centerX + Math.cos(angle) * radius * 0.85, centerY + Math.sin(angle) * radius * 0.85); ctx.stroke();
                ctx.shadowColor = 'transparent';
                animationFrameIdGauge = requestAnimationFrame(() => drawGauge(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawGauge, null);
            return panel;
        }

        // Code Scroll Panel (Vertically scrolling code-like glyphs)
        function createCodeScrollPanel(areaName) {
            const { panel } = createPanelShell('code-scroll', areaName);
            const contentDiv = document.createElement('div');
            contentDiv.className = 'code-scroll-content';
            panel.appendChild(contentDiv);
            const estimatedLineHeight = 14;
            const maxHistoryLines = 60;
            let initialFillDone = false;

            function attemptFill() {
                if (!panel.isConnected) return false;
                if (!contentDiv.clientWidth || !contentDiv.clientHeight) {
                    if (panel.clientHeight > 0) { requestAnimationFrame(attemptFill); } return false;
                }
                const panelWidth = contentDiv.clientWidth;
                const visibleLines = Math.floor(contentDiv.clientHeight / estimatedLineHeight);
                const linesToInitiallyFill = Math.max(1, Math.min(visibleLines + 5, maxHistoryLines - 5));
                if (!initialFillDone) {
                    for(let i = 0; i < linesToInitiallyFill; i++) {
                        if (contentDiv.children.length < maxHistoryLines) {
                            const newLine = generateAlienSVGLine(Math.floor(Math.random() * 20) + 15, panelWidth);
                            if(Math.random() < 0.3) newLine.classList.add('indent-1'); else if (Math.random() < 0.1) newLine.classList.add('indent-2');
                            contentDiv.appendChild(newLine);
                        }
                    }
                    contentDiv.scrollTop = contentDiv.scrollHeight; initialFillDone = true;
                } return true;
            }

            function updateScroll() {
                if (!panel.isConnected) return;
                if (!initialFillDone) { if(!attemptFill()) return; }
                if (!contentDiv.clientWidth) return;

                const panelWidth = contentDiv.clientWidth;
                if (contentDiv.children.length < maxHistoryLines || Math.random() < 0.25) {
                    const newLine = generateAlienSVGLine(Math.floor(Math.random() * 20) + 15, panelWidth);
                    if(Math.random() < 0.3) newLine.classList.add('indent-1'); else if (Math.random() < 0.1) newLine.classList.add('indent-2');
                    contentDiv.appendChild(newLine);
                }
                if (contentDiv.children.length > maxHistoryLines) contentDiv.removeChild(contentDiv.firstChild);

                contentDiv.scrollTop += 1; 
                if (contentDiv.scrollTop >= contentDiv.scrollHeight - contentDiv.clientHeight - 5) { 
                    contentDiv.scrollTop = 0; 
                }
            }
            panel.initContent = attemptFill;
            panelUpdateIntervals.push(setInterval(updateScroll, 60)); 
            return panel;
        }
        // Heatmap Panel (Grid of colored cells on canvas)
        function createHeatmapPanel(areaName) {
            const { panel } = createPanelShell('heatmap', areaName);
            const canvas = document.createElement('canvas');
            canvas.className = 'heatmap-canvas';
            panel.appendChild(canvas);
            let animationFrameIdHeatmap;
            const gridSize = 12; let cellValues = []; 
            canvas.clearAnimation = () => { if (animationFrameIdHeatmap) cancelAnimationFrame(animationFrameIdHeatmap); animationFrameIdHeatmap = null; };
            function initHeatmap(w,h) { cellValues = Array(gridSize * gridSize).fill(0).map(() => Math.random());} 
            function drawHeatmap(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdHeatmap) cancelAnimationFrame(animationFrameIdHeatmap); animationFrameIdHeatmap = null; return; }
                const ctx = canvasEl.getContext('2d');
                const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animationFrameIdHeatmap = requestAnimationFrame(() => drawHeatmap(canvasEl)); return;}
                if(cellValues.length === 0) initHeatmap(w,h); 
                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                const cellW = w / gridSize, cellH = h / gridSize;
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const index = y * gridSize + x;
                        cellValues[index] += (Math.random() - 0.5) * 0.15; cellValues[index] = Math.max(0.05, Math.min(0.9, cellValues[index]));
                        ctx.fillStyle = `rgba(${baseRGB}, ${cellValues[index]})`;
                        ctx.fillRect(x * cellW, y * cellH, cellW -0.5, cellH -0.5); 
                    }
                }
                animationFrameIdHeatmap = requestAnimationFrame(() => drawHeatmap(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawHeatmap, initHeatmap);
            return panel;
        }
        // System Tree Panel (Hierarchical list of glyph lines)
        function createSystemTreePanel(areaName) { const { panel, title } = createPanelShell('system-tree', areaName); const treeContainer = document.createElement('div'); treeContainer.style.overflowY = 'auto'; treeContainer.style.flexGrow = '1'; panel.appendChild(treeContainer); function buildBranch(parentElement, depth, maxDepth, panelHeight, panelWidth) { if (!panel.isConnected || depth > maxDepth || panelHeight <=0 || panelWidth <=0) return; const estimatedNodeHeight = 15; const maxChildren = Math.max(1, Math.floor(panelHeight / (estimatedNodeHeight * (depth +1.5) )) ); const numChildren = Math.min(Math.floor(Math.random() * 3) + (depth === 0 ? 2:1), maxChildren); for (let i = 0; i < numChildren; i++) { const node = document.createElement('div'); node.className = 'system-tree-node'; node.style.paddingLeft = (depth * 8) + 'px'; const line = generateAlienSVGLine(Math.floor(Math.random()*8)+8, panelWidth - (depth * 8)); node.appendChild(line); parentElement.appendChild(node); if (Math.random() < 0.65 - depth * 0.1) buildBranch(node, depth + 1, maxDepth, panelHeight, panelWidth - 8); } } const initTree = () => { if (!panel.isConnected) return; if (!treeContainer.clientHeight && panel.clientHeight > (title.offsetHeight + 10)) { requestAnimationFrame(initTree); return; } treeContainer.innerHTML = ''; const pHeight = treeContainer.clientHeight; if(pHeight <=0) return; const pWidth = treeContainer.clientWidth - 16; if(pHeight > 0 && pWidth > 0) buildBranch(treeContainer, 0, 3, pHeight, pWidth); }; panel.initContent = initTree; return panel; }
        // Keypad Panel (Grid of single-glyph buttons)
        function createKeypadPanel(areaName) { const { panel, title } = createPanelShell('keypad', areaName); const grid = document.createElement('div'); grid.className = 'keypad-grid'; panel.appendChild(grid); const initKeypad = () => { if (!panel.isConnected) return; if (!grid.clientHeight && panel.clientHeight > (title.offsetHeight + 10)) { requestAnimationFrame(initKeypad); return; } grid.innerHTML = ''; const panelContentHeight = grid.clientHeight; const panelContentWidth = grid.clientWidth; if (panelContentHeight <=0 || panelContentWidth <=0) return; const keySize = 30; const numCols = Math.max(1, Math.floor(panelContentWidth / keySize)); const numRows = Math.max(1, Math.floor(panelContentHeight / keySize)); const numKeys = Math.min(16, numCols * numRows); for (let i = 0; i < numKeys; i++) { const key = document.createElement('div'); key.className = 'keypad-button'; if (Math.random() < 0.15) key.style.backgroundColor = `rgba(var(--base-phosphor-color-rgb), 0.3)`; generateAlienSVGSequence(1, key); grid.appendChild(key); key.onclick = () => { if (!panel.isConnected) return; key.classList.add('active'); displayAlertMessage(1, 500); setTimeout(() => key.classList.remove('active'), 150); }; } }; panel.initContent = initKeypad; return panel; }
        // Orbital Path Panel (Planets orbiting a center on canvas)
        function createOrbitalPathPanel(areaName) {
            const { panel } = createPanelShell('orbital-path', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'orbital-path-canvas'; panel.appendChild(canvas);
            let animationFrameIdOrbital; const planets = []; const numPlanets = 5;
            canvas.clearAnimation = () => { if (animationFrameIdOrbital) cancelAnimationFrame(animationFrameIdOrbital); animationFrameIdOrbital = null; };

            function initOrbital(w, h) { 
                planets.length = 0; const centerX = w / 2; const centerY = h / 2;
                for (let i = 0; i < numPlanets; i++) { planets.push({ radius: Math.random() * (Math.min(w,h) * 0.08) + (Math.min(w,h) * 0.12), angle: Math.random() * Math.PI * 2, speed: (Math.random() - 0.5) * 0.015 + 0.003, size: Math.random() * (Math.min(w,h) * 0.008) + (Math.min(w,h) * 0.004) }); }
            }
            function drawOrbital(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdOrbital) cancelAnimationFrame(animationFrameIdOrbital); animationFrameIdOrbital = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animationFrameIdOrbital = requestAnimationFrame(() => drawOrbital(canvasEl)); return;}
                if(planets.length === 0 && w > 0 && h > 0) initOrbital(w,h); 

                const centerX = w / 2; const centerY = h / 2; ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                const primaryColor = `rgb(${baseRGB})`; const glowColor = `rgba(${baseRGB}, 0.3)`;
                ctx.fillStyle = primaryColor; ctx.shadowColor = glowColor; ctx.shadowBlur = 5;
                ctx.beginPath(); ctx.arc(centerX, centerY, Math.min(w,h) * 0.03, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; 
                planets.forEach(p => {
                    p.angle += p.speed; 
                    const x = centerX + Math.cos(p.angle) * p.radius; const y = centerY + Math.sin(p.angle) * p.radius;
                    ctx.strokeStyle = `rgba(${baseRGB}, 0.15)`; ctx.lineWidth = 0.5;
                    ctx.beginPath(); ctx.arc(centerX, centerY, p.radius, 0, Math.PI * 2); ctx.stroke();
                    ctx.fillStyle = primaryColor; ctx.beginPath(); ctx.arc(x, y, p.size, 0, Math.PI * 2); ctx.fill();
                });
                animationFrameIdOrbital = requestAnimationFrame(() => drawOrbital(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawOrbital, initOrbital);
            return panel;
        }
        // Frequency Spectrum Panel (Animated vertical bars on canvas)
        function createFrequencySpectrumPanel(areaName) {
            const { panel } = createPanelShell('frequency-spectrum', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'frequency-spectrum-canvas'; panel.appendChild(canvas);
            let animationFrameIdSpectrum; const numBars = 20; let barHeights = new Array(numBars).fill(0);
            canvas.clearAnimation = () => { if (animationFrameIdSpectrum) cancelAnimationFrame(animationFrameIdSpectrum); animationFrameIdSpectrum = null; };
            function initSpectrum(w,h){ barHeights = new Array(numBars).fill(0).map(()=> Math.random() * h * 0.7); }
            function drawSpectrum(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdSpectrum) cancelAnimationFrame(animationFrameIdSpectrum); animationFrameIdSpectrum = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animationFrameIdSpectrum = requestAnimationFrame(() => drawSpectrum(canvasEl)); return;}
                if(barHeights.length === 0 && h > 0) initSpectrum(w,h); 
                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                const barWidth = w / numBars;
                for (let i = 0; i < numBars; i++) {
                    barHeights[i] += (Math.random() - 0.5) * (h * 0.2); barHeights[i] = Math.max(0, Math.min(h * 0.9, barHeights[i] + (Math.random() * (h*0.1) - (h*0.05)) ));
                    if (Math.random() < 0.1) barHeights[i] = Math.random() * h * 0.7; 
                    ctx.fillStyle = `rgba(${baseRGB}, ${0.3 + Math.random() * 0.6})`; 
                    ctx.fillRect(i * barWidth, h - barHeights[i], barWidth * 0.8, barHeights[i]); 
                }
                animationFrameIdSpectrum = requestAnimationFrame(() => drawSpectrum(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawSpectrum, initSpectrum);
            return panel;
        }
        
// --- NEW PANEL: Plasma Insulator Field Panel ---
        function createPlasmaInsulatorFieldPanel(areaName) {
            const { panel } = createPanelShell('plasma-field', areaName);
            const canvas = document.createElement('canvas');
            canvas.className = 'main-display-canvas'; // Use common class
            panel.appendChild(canvas);

            let animationFrameId;
            let gridPoints = [];
            let zaps = [];
            const gridSize = 10; // Affects density of points

            canvas.clearAnimation = () => {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            };

            function initPlasmaField(w, h) {
                gridPoints = [];
                zaps = [];
                const cellW = w / gridSize;
                const cellH = h / gridSize;
                for (let r = 0; r <= gridSize; r++) {
                    for (let c = 0; c <= gridSize; c++) {
                        gridPoints.push({ x: c * cellW, y: r * cellH });
                    }
                }
            }

            function drawPlasmaField(canvasEl) {
                if (!canvasEl.isConnected) {
                    canvas.clearAnimation();
                    return;
                }
                const ctx = canvasEl.getContext('2d');
                const w = canvasEl.width, h = canvasEl.height;

                if (w <= 0 || h <= 0) {
                    animationFrameId = requestAnimationFrame(() => drawPlasmaField(canvasEl));
                    return;
                }
                if (gridPoints.length === 0 || Math.abs(w / gridSize - (gridPoints[1]?.x - gridPoints[0]?.x)) > 5) { // Re-init if size changed much
                    initPlasmaField(w, h);
                }

                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                const primaryColor = `rgb(${baseRGB})`;

                // Draw faint grid points (optional)
                // ctx.fillStyle = `rgba(${baseRGB}, 0.1)`;
                // gridPoints.forEach(p => ctx.fillRect(p.x - 0.5, p.y - 0.5, 1, 1));

                // Add new zaps occasionally
                if (Math.random() < 0.15 && gridPoints.length > 1) { // Adjust spawn rate
                    const p1 = gridPoints[Math.floor(Math.random() * gridPoints.length)];
                    const p2 = gridPoints[Math.floor(Math.random() * gridPoints.length)];
                    if (p1 !== p2) {
                        zaps.push({
                            x1: p1.x, y1: p1.y,
                            x2: p2.x, y2: p2.y,
                            segments: 3 + Math.floor(Math.random() * 3),
                            alpha: 0.8 + Math.random() * 0.2,
                            life: 10 + Math.floor(Math.random() * 10) // Shorter life
                        });
                    }
                }

                // Draw and update zaps
                ctx.lineWidth = Math.random() * 1.5 + 0.5;
                for (let i = zaps.length - 1; i >= 0; i--) {
                    const zap = zaps[i];
                    ctx.strokeStyle = `rgba(${baseRGB}, ${zap.alpha})`;
                    ctx.beginPath();
                    ctx.moveTo(zap.x1, zap.y1);
                    let prevX = zap.x1;
                    let prevY = zap.y1;
                    for (let s = 1; s < zap.segments; s++) {
                        const t = s / zap.segments;
                        const midX = prevX + (zap.x2 - prevX) * t + (Math.random() - 0.5) * 20; // Jaggedness
                        const midY = prevY + (zap.y2 - prevY) * t + (Math.random() - 0.5) * 20;
                        ctx.lineTo(midX, midY);
                    }
                    ctx.lineTo(zap.x2, zap.y2);
                    ctx.stroke();

                    zap.life--;
                    zap.alpha -= 0.08; // Faster fade
                    if (zap.life <= 0 || zap.alpha <= 0) {
                        zaps.splice(i, 1);
                    }
                }
                animationFrameId = requestAnimationFrame(() => drawPlasmaField(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawPlasmaField, initPlasmaField);
            return panel;
        }

        // --- NEW PANEL: Subspace Anomalies Panel ---
        function createSubspaceAnomaliesPanel(areaName) {
            const { panel } = createPanelShell('subspace-anomalies', areaName);
            const canvas = document.createElement('canvas');
            canvas.className = 'main-display-canvas';
            panel.appendChild(canvas);

            let animationFrameId;
            const anomalies = [];
            const maxAnomalies = 5;
            const nebulae = [];
            const numNebulae = 3;

            canvas.clearAnimation = () => {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            };

            function initSubspace(w, h) {
                anomalies.length = 0;
                nebulae.length = 0;
                for(let i=0; i < numNebulae; i++) {
                    nebulae.push({
                        x: Math.random() * w,
                        y: Math.random() * h,
                        radius: Math.random() * (Math.min(w,h)/3) + (Math.min(w,h)/4),
                        alpha: Math.random() * 0.02 + 0.01, // Very faint
                        vx: (Math.random() - 0.5) * 0.1,
                        vy: (Math.random() - 0.5) * 0.1,
                        colorVariation: Math.random() * 0.1 // Slight tint variation
                    });
                }
            }

            function drawSubspace(canvasEl) {
                if (!canvasEl.isConnected) {
                    canvas.clearAnimation();
                    return;
                }
                const ctx = canvasEl.getContext('2d');
                const w = canvasEl.width, h = canvasEl.height;

                if (w <= 0 || h <= 0) {
                    animationFrameId = requestAnimationFrame(() => drawSubspace(canvasEl));
                    return;
                }
                if (nebulae.length === 0) initSubspace(w,h);

                ctx.clearRect(0, 0, w, h);
                const baseRGBVal = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                
                // Draw nebulae (large, faint, slowly moving clouds)
                nebulae.forEach(neb => {
                    neb.x += neb.vx; neb.y += neb.vy;
                    if (neb.x + neb.radius < 0 || neb.x - neb.radius > w) neb.vx *= -1;
                    if (neb.y + neb.radius < 0 || neb.y - neb.radius > h) neb.vy *= -1;

                    const gradient = ctx.createRadialGradient(neb.x, neb.y, neb.radius * 0.1, neb.x, neb.y, neb.radius);
                    gradient.addColorStop(0, `rgba(${baseRGBVal}, ${neb.alpha + neb.colorVariation})`);
                    gradient.addColorStop(1, `rgba(${baseRGBVal}, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(neb.x - neb.radius, neb.y - neb.radius, neb.radius * 2, neb.radius * 2);
                });


                // Add new anomalies occasionally
                if (anomalies.length < maxAnomalies && Math.random() < 0.01) {
                    const type = Math.random() < 0.6 ? 'ripple' : 'streak';
                    if (type === 'ripple') {
                        anomalies.push({
                            type: 'ripple', x: Math.random() * w, y: Math.random() * h,
                            radius: 0, maxRadius: Math.random() * 50 + 20,
                            alpha: 0.7, life: 60
                        });
                    } else {
                        anomalies.push({
                            type: 'streak', x1: Math.random() * w, y1: Math.random() * h,
                            x2: Math.random() * w, y2: Math.random() * h,
                            progress: 0, alpha: 0.9, life: 80
                        });
                    }
                }

                // Draw and update anomalies
                ctx.lineWidth = 1.5;
                for (let i = anomalies.length - 1; i >= 0; i--) {
                    const anom = anomalies[i];
                    anom.life--;
                    if (anom.life <= 0) {
                        anomalies.splice(i, 1);
                        continue;
                    }
                    if (anom.type === 'ripple') {
                        anom.radius += anom.maxRadius / 60;
                        anom.alpha = (anom.life / 60) * 0.7;
                        ctx.strokeStyle = `rgba(${baseRGBVal}, ${anom.alpha})`;
                        ctx.beginPath();
                        ctx.arc(anom.x, anom.y, anom.radius, 0, Math.PI * 2);
                        ctx.stroke();
                    } else if (anom.type === 'streak') {
                        anom.progress += 0.05;
                        anom.alpha = (anom.life / 80) * 0.9;
                        const currentX = anom.x1 + (anom.x2 - anom.x1) * Math.min(1, anom.progress);
                        const currentY = anom.y1 + (anom.y2 - anom.y1) * Math.min(1, anom.progress);
                        const tailLength = 30;
                        const startX = anom.x1 + (anom.x2 - anom.x1) * Math.max(0, anom.progress - (tailLength / Math.hypot(anom.x2-anom.x1, anom.y2-anom.y1) * 0.1));
                        const startY = anom.y1 + (anom.y2 - anom.y1) * Math.max(0, anom.progress - (tailLength / Math.hypot(anom.x2-anom.x1, anom.y2-anom.y1) * 0.1));

                        if (anom.progress < 1.1) { // Draw while streak is "active" or just finished
                           const grad = ctx.createLinearGradient(startX, startY, currentX, currentY);
                           grad.addColorStop(0, `rgba(${baseRGBVal}, 0)`);
                           grad.addColorStop(1, `rgba(${baseRGBVal}, ${anom.alpha})`);
                           ctx.strokeStyle = grad;
                           ctx.beginPath();
                           ctx.moveTo(startX, startY);
                           ctx.lineTo(currentX, currentY);
                           ctx.stroke();
                        }
                         if(anom.progress > 1) anom.life -=2; // Fade faster after completion
                    }
                }
                animationFrameId = requestAnimationFrame(() => drawSubspace(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawSubspace, initSubspace);
            return panel;
        }

        // --- NEW PANEL: Artifact Scanner Panel ---
        function createArtifactScannerPanel(areaName) {
            const { panel } = createPanelShell('artifact-scanner', areaName);
            const canvas = document.createElement('canvas');
            canvas.className = 'main-display-canvas';
            panel.appendChild(canvas);

            let animationFrameId;
            let artifactPoints3D = [];
            let artifactEdges = [];
            let rotationX = 0, rotationY = 0, rotationZ = 0;
            let scanLineY = 0;
            let scanDirection = 1;
            const highlightedPoints = []; // {x, y, alpha}

            canvas.clearAnimation = () => {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            };

            function defineArtifact() { // Simple interconnected cubes
                const s = 1; // half-size
                const points = [
                    [-s,-s,-s], [s,-s,-s], [s,s,-s], [-s,s,-s],
                    [-s,-s,s], [s,-s,s], [s,s,s], [-s,s,s]
                ];
                const edges = [
                    [0,1],[1,2],[2,3],[3,0], [4,5],[5,6],[6,7],[7,4],
                    [0,4],[1,5],[2,6],[3,7]
                ];
                // Add a second, smaller, offset cube
                const s2 = 0.5, offset = 1.5;
                 for(let i=0; i<8; i++) {
                    points.push([points[i][0]*s2 + offset, points[i][1]*s2, points[i][2]*s2 + offset]);
                 }
                 for(let i=0; i<12; i++) {
                    edges.push([edges[i][0]+8, edges[i][1]+8]);
                 }
                 edges.push([2,8]); // Connect the two cubes
                 edges.push([5,11]);

                artifactPoints3D = points;
                artifactEdges = edges;
            }

            function projectPoint(p3d, w, h, scale) {
                const x = p3d[0], y = p3d[1], z = p3d[2];
                // Simple perspective projection
                const perspective = 3 / (3 - z * 0.3); // Keep z positive for this simple projection
                return {
                    x: w / 2 + (x * perspective * scale),
                    y: h / 2 + (y * perspective * scale),
                    z_orig: z
                };
            }
            
            function initArtifactScanner(w,h){
                defineArtifact();
                scanLineY = 0;
                scanDirection = (h/100);
                if (scanDirection === 0) scanDirection = 1;
            }


            function drawArtifactScanner(canvasEl) {
                if (!canvasEl.isConnected) {
                    canvas.clearAnimation();
                    return;
                }
                const ctx = canvasEl.getContext('2d');
                const w = canvasEl.width, h = canvasEl.height;

                if (w <= 0 || h <= 0) {
                    animationFrameId = requestAnimationFrame(() => drawArtifactScanner(canvasEl));
                    return;
                }
                 if(artifactPoints3D.length === 0) initArtifactScanner(w,h);


                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                const primaryColor = `rgb(${baseRGB})`;
                const scale = Math.min(w, h) / 5;

                rotationX += 0.003; rotationY += 0.005; rotationZ += 0.001;

                const rotatedPoints2D = artifactPoints3D.map(p => {
                    let x = p[0], y = p[1], z = p[2];
                    // Rotate X
                    let tempY = y * Math.cos(rotationX) - z * Math.sin(rotationX);
                    let tempZ = y * Math.sin(rotationX) + z * Math.cos(rotationX);
                    y = tempY; z = tempZ;
                    // Rotate Y
                    let tempX = x * Math.cos(rotationY) - z * Math.sin(rotationY);
                    tempZ = x * Math.sin(rotationY) + z * Math.cos(rotationY);
                    x = tempX; z = tempZ;
                     // Rotate Z
                    tempX = x * Math.cos(rotationZ) - y * Math.sin(rotationZ);
                    tempY = x * Math.sin(rotationZ) + y * Math.cos(rotationZ);
                    x = tempX; y = tempY;

                    return projectPoint([x,y,z], w, h, scale);
                });

                // Draw artifact edges
                ctx.strokeStyle = primaryColor;
                ctx.lineWidth = 0.75;
                artifactEdges.forEach(edge => {
                    const p1 = rotatedPoints2D[edge[0]];
                    const p2 = rotatedPoints2D[edge[1]];
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                });

                // Update and draw scan line
                scanLineY += scanDirection;
                if (scanLineY > h || scanLineY < 0) {
                    scanDirection *= -1;
                    scanLineY += scanDirection * 2; // step back into view
                }
                ctx.strokeStyle = `rgba(${baseRGB}, 0.5)`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, scanLineY);
                ctx.lineTo(w, scanLineY);
                ctx.stroke();

                // Check for scan line intersections and create highlights
                 rotatedPoints2D.forEach(p2d => {
                    if (Math.abs(p2d.y - scanLineY) < 2 && Math.random() < 0.05) { // If point is near scanline
                        highlightedPoints.push({ x: p2d.x, y: p2d.y, alpha: 1.0 });
                    }
                });

                // Draw and fade highlights
                for(let i = highlightedPoints.length - 1; i >= 0; i--) {
                    const hp = highlightedPoints[i];
                    hp.alpha -= 0.05;
                    if (hp.alpha <= 0) {
                        highlightedPoints.splice(i,1);
                        continue;
                    }
                    ctx.fillStyle = `rgba(${baseRGB}, ${hp.alpha * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(hp.x, hp.y, 1.5, 0, Math.PI*2);
                    ctx.fill();
                }

                animationFrameId = requestAnimationFrame(() => drawArtifactScanner(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawArtifactScanner, initArtifactScanner);
            return panel;
        }

        // System Log Panel (Timestamped log entries)
        function createSystemLogPanel(areaName) {
            const { panel } = createPanelShell('system-log', areaName);
            const logContent = document.createElement('div');
            logContent.className = 'system-log-content';
            panel.appendChild(logContent);
            const estimatedLineHeight = 15;
            const maxHistoryLines = 35;
            let initialFillDone = false;

            function attemptFill() {
                if (!panel.isConnected) return false;
                if (!logContent.clientWidth || !logContent.clientHeight) {
                    if (panel.clientHeight > 0) { requestAnimationFrame(attemptFill); } return false;
                }
                const panelWidth = logContent.clientWidth;
                const visibleLines = Math.floor(logContent.clientHeight / estimatedLineHeight);
                const linesToInitiallyFill = Math.max(1, Math.min(visibleLines + 3, maxHistoryLines - 3));
                if (!initialFillDone) {
                    for(let i = 0; i < linesToInitiallyFill; i++) {
                        if (logContent.children.length < maxHistoryLines) {
                             const entry = document.createElement('div'); entry.className = 'system-log-entry';
                            const timestampSpan = document.createElement('span'); generateAlienSVGSequence(Math.floor(Math.random() * 5) + 7, timestampSpan); timestampSpan.style.opacity = "0.7";
                            const messageSpan = document.createElement('span'); generateAlienSVGSequence(Math.floor(Math.random() * 12) + 12, messageSpan);
                            entry.appendChild(timestampSpan); entry.appendChild(messageSpan);
                            logContent.appendChild(entry);
                        }
                    }
                    logContent.scrollTop = logContent.scrollHeight; initialFillDone = true;
                } return true;
            }

            function updateLog() {
                if (!panel.isConnected) return;
                if (!initialFillDone) { if(!attemptFill()) return; }
                if (!logContent.clientWidth) return;

                const panelWidth = logContent.clientWidth;
                const entry = document.createElement('div'); entry.className = 'system-log-entry';
                const timestampSpan = document.createElement('span'); generateAlienSVGSequence(Math.floor(Math.random() * 5) + 7, timestampSpan); timestampSpan.style.opacity = "0.7";
                const messageSpan = document.createElement('span'); generateAlienSVGSequence(Math.floor(Math.random() * 12) + 12, messageSpan);
                entry.appendChild(timestampSpan); entry.appendChild(messageSpan);
                logContent.appendChild(entry);

                if (logContent.children.length > maxHistoryLines) logContent.removeChild(logContent.firstChild);
                logContent.scrollTop = logContent.scrollHeight;
            }
            panel.initContent = attemptFill;
            panelUpdateIntervals.push(setInterval(updateLog, 3000 + Math.random() * 1500)); 
            return panel;
        }
        // Energy Flow Panel (Flowing particles on canvas)
        function createEnergyFlowPanel(areaName) {
            const { panel } = createPanelShell('energy-flow', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'energy-flow-canvas'; panel.appendChild(canvas);
            let animationFrameIdFlow; let particles = []; const numParticles = 20; 
            canvas.clearAnimation = () => { if (animationFrameIdFlow) cancelAnimationFrame(animationFrameIdFlow); animationFrameIdFlow = null; };
            function initFlow(w,h) { 
                particles = [];
                for (let i = 0; i < numParticles; i++) { particles.push({ x: Math.random() * w, y: Math.random() * h, vx: (Math.random() - 0.5) * 1.2 + (w > h ? (Math.random() > 0.5 ? 0.8 : -0.8) * 0.4 : 0), vy: (Math.random() - 0.5) * 1.2 + (h > w ? (Math.random() > 0.5 ? 0.8 : -0.8) * 0.4 : 0), size: Math.random() * 1.5 + 0.8, alpha: Math.random() * 0.4 + 0.25, life: Math.random() * 70 + 30 }); } 
            }
            function drawFlow(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdFlow) cancelAnimationFrame(animationFrameIdFlow); animationFrameIdFlow = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animationFrameIdFlow = requestAnimationFrame(() => drawFlow(canvasEl)); return;}
                if(particles.length === 0) initFlow(w,h); 
                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                particles.forEach(p => {
                    p.x += p.vx; p.y += p.vy; p.life--; p.alpha -= 0.008; 
                    if (p.x < 0 || p.x > w || p.y < 0 || p.y > h || p.life <= 0 || p.alpha <=0) {
                        p.x = Math.random() * w; p.y = Math.random() * h;
                        p.vx = (Math.random() - 0.5) * 1.2 + (w > h ? (Math.random() > 0.5 ? 0.8 : -0.8) * 0.4 : 0); 
                        p.vy = (Math.random() - 0.5) * 1.2 + (h > w ? (Math.random() > 0.5 ? 0.8 : -0.8) * 0.4 : 0);
                        p.alpha = Math.random() * 0.4 + 0.25; p.life = Math.random() * 70 + 30;
                    }
                    ctx.fillStyle = `rgba(${baseRGB}, ${p.alpha})`; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
                });
                animationFrameIdFlow = requestAnimationFrame(() => drawFlow(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawFlow, initFlow);
            return panel;
        }
        // Targeting Reticule Panel (Animated crosshair on canvas)
        function createTargetingReticulePanel(areaName) {
            const { panel } = createPanelShell('targeting-reticule', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'targeting-reticule-canvas'; panel.appendChild(canvas);
            let animationFrameIdReticule; let crosshairX, crosshairY; let targetOffsetX = 0, targetOffsetY = 0; 
            canvas.clearAnimation = () => { if (animationFrameIdReticule) cancelAnimationFrame(animationFrameIdReticule); animationFrameIdReticule = null; };
            function drawReticule(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdReticule) cancelAnimationFrame(animationFrameIdReticule); animationFrameIdReticule = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animationFrameIdReticule = requestAnimationFrame(() => drawReticule(canvasEl)); return;}
                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                const primaryColor = `rgb(${baseRGB})`; const glowColor = `rgba(${baseRGB}, 0.4)`;
                if (crosshairX === undefined) { crosshairX = w/2; crosshairY = h/2; } 
                targetOffsetX += (Math.random() - 0.5) * 0.5; targetOffsetY += (Math.random() - 0.5) * 0.5;
                targetOffsetX = Math.max(-w/4, Math.min(w/4, targetOffsetX)); targetOffsetY = Math.max(-h/4, Math.min(h/4, targetOffsetY));
                crosshairX = w/2 + targetOffsetX; crosshairY = h/2 + targetOffsetY;

                ctx.strokeStyle = primaryColor; ctx.lineWidth = Math.max(1, Math.min(w,h) * 0.005); ctx.shadowColor = glowColor; ctx.shadowBlur = 3;
                ctx.beginPath(); ctx.arc(crosshairX, crosshairY, Math.min(w,h) * 0.3, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.arc(crosshairX, crosshairY, Math.min(w,h) * 0.15, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(crosshairX - Math.min(w,h) * 0.35, crosshairY); ctx.lineTo(crosshairX + Math.min(w,h) * 0.35, crosshairY); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(crosshairX, crosshairY - Math.min(w,h) * 0.35); ctx.lineTo(crosshairX, crosshairY + Math.min(w,h) * 0.35); ctx.stroke();
                const bracketSize = Math.min(w,h) * 0.1;
                ctx.beginPath(); ctx.moveTo(crosshairX - bracketSize, crosshairY - bracketSize); ctx.lineTo(crosshairX - bracketSize*1.5, crosshairY - bracketSize); ctx.moveTo(crosshairX - bracketSize, crosshairY - bracketSize); ctx.lineTo(crosshairX - bracketSize, crosshairY - bracketSize*1.5); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(crosshairX + bracketSize, crosshairY - bracketSize); ctx.lineTo(crosshairX + bracketSize*1.5, crosshairY - bracketSize); ctx.moveTo(crosshairX + bracketSize, crosshairY - bracketSize); ctx.lineTo(crosshairX + bracketSize, crosshairY - bracketSize*1.5); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(crosshairX - bracketSize, crosshairY + bracketSize); ctx.lineTo(crosshairX - bracketSize*1.5, crosshairY + bracketSize); ctx.moveTo(crosshairX - bracketSize, crosshairY + bracketSize); ctx.lineTo(crosshairX - bracketSize, crosshairY + bracketSize*1.5); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(crosshairX + bracketSize, crosshairY + bracketSize); ctx.lineTo(crosshairX + bracketSize*1.5, crosshairY + bracketSize); ctx.moveTo(crosshairX + bracketSize, crosshairY + bracketSize); ctx.lineTo(crosshairX + bracketSize, crosshairY + bracketSize*1.5); ctx.stroke();
                ctx.shadowColor = 'transparent';
                animationFrameIdReticule = requestAnimationFrame(() => drawReticule(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawReticule, null);
            return panel;
        }
        // Data Packet Panel (Small data blocks with progress bars)
        function createDataPacketPanel(areaName) { const { panel, title } = createPanelShell('data-packet', areaName); const contentDiv = document.createElement('div'); contentDiv.className = 'data-packet-content'; panel.appendChild(contentDiv); const addPacket = () => { if(!panel.isConnected || !contentDiv.clientWidth) return; const panelWidth = contentDiv.clientWidth; const packet = document.createElement('div'); packet.className = 'data-packet'; generateAlienSVGSequence(Math.floor(Math.random() * 6) + 5, packet); const progressBarContainer = document.createElement('div'); progressBarContainer.className = 'progress-bar-container'; progressBarContainer.style.width = (Math.random() * 30 + 40) + 'px'; progressBarContainer.style.height = '0.3em'; progressBarContainer.style.marginLeft = '5px'; const progressBarFill = document.createElement('div'); progressBarFill.className = 'progress-bar-fill'; progressBarFill.style.width = (Math.random() * 100) + '%'; progressBarContainer.appendChild(progressBarFill); packet.appendChild(progressBarContainer); contentDiv.appendChild(packet); if (contentDiv.children.length > 8) { contentDiv.removeChild(contentDiv.firstChild); } if (Math.random() < 0.5 && contentDiv.children.length > 0) { const randomPacket = contentDiv.children[Math.floor(Math.random() * contentDiv.children.length)]; const barFill = randomPacket.querySelector('.progress-bar-fill'); if (barFill) barFill.style.width = (Math.random() * 100) + '%'; } }; setTimeout(addPacket, 50); panelUpdateIntervals.push(setInterval(addPacket, 2500 + Math.random() * 1000)); panel.initContent = addPacket; return panel; }
        // Security Access Panel (Blinking security status)
        function createSecurityAccessPanel(areaName) {
            const { panel } = createPanelShell('security-access', areaName);
            const contentDiv = document.createElement('div');
            contentDiv.className = 'security-access-content';
            panel.appendChild(contentDiv);

            const sequenceLine = document.createElement('div'); 
            const statusLine = document.createElement('div'); 
            statusLine.className = 'security-status-line';
            contentDiv.appendChild(sequenceLine);
            contentDiv.appendChild(statusLine);

            const updateSecurity = () => {
                if (!panel.isConnected) return;
                generateAlienSVGSequence(Math.floor(Math.random() * 10) + 15, sequenceLine, Math.random() < 0.2); 
                if (Math.random() < 0.3 || statusLine.childNodes.length === 0) { 
                    statusLine.innerHTML = ''; 
                    generateAlienSVGSequence(Math.floor(Math.random() * 8) + 7, statusLine, true); 
                }
            };
            setTimeout(updateSecurity, 50); 
            panelUpdateIntervals.push(setInterval(updateSecurity, 2500 + Math.random() * 1500));
            panel.initContent = updateSecurity;
            return panel;
        }
        // Starmap Panel (Blinking stars on canvas)
        function createStarmapPanel(areaName) {
            const { panel } = createPanelShell('starmap', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'starmap-canvas'; panel.appendChild(canvas);
            let animationFrameIdStarmap; let stars = []; const numStars = 100; 
            canvas.clearAnimation = () => { if (animationFrameIdStarmap) cancelAnimationFrame(animationFrameIdStarmap); animationFrameIdStarmap = null; };
            function initStars(w,h) { 
                stars = []; for (let i = 0; i < numStars; i++) { stars.push({ x: Math.random() * w, y: Math.random() * h, size: Math.random() * 1.5 + 0.5, alpha: Math.random() * 0.5 + 0.2, blinkSpeed: Math.random() * 0.05 + 0.01, blinkPhase: Math.random() * Math.PI * 2 }); }
            }
            function drawStarmap(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdStarmap) cancelAnimationFrame(animationFrameIdStarmap); animationFrameIdStarmap = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animationFrameIdStarmap = requestAnimationFrame(() => drawStarmap(canvasEl)); return;}
                if(stars.length === 0) initStars(w,h); 
                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                stars.forEach(s => {
                    s.blinkPhase += s.blinkSpeed; 
                    const currentAlpha = s.alpha + (Math.sin(s.blinkPhase) * (s.alpha * 0.8)); 
                    ctx.fillStyle = `rgba(${baseRGB}, ${Math.max(0.1, Math.min(1, currentAlpha))})`;
                    ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2); ctx.fill();
                });
                for(let i=0; i< Math.floor(Math.min(w,h)/150); i++){ 
                    ctx.fillStyle = `rgba(${baseRGB}, ${0.02 + Math.random()*0.03})`; ctx.beginPath();
                    ctx.ellipse(Math.random()*w, Math.random()*h, Math.random()*w*0.15 + w*0.05, Math.random()*h*0.15+h*0.05, Math.random()*Math.PI, 0, Math.PI*2); ctx.fill();
                }
                animationFrameIdStarmap = requestAnimationFrame(() => drawStarmap(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawStarmap, initStars);
            return panel;
        }
        // Pulse Wave Panel (Expanding pulse on canvas)
        function createPulseWavePanel(areaName) {
            const { panel } = createPanelShell('pulse-wave', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'pulse-wave-canvas'; panel.appendChild(canvas);
            let animationFrameIdPulse; let pulseRadius = 0; let pulseMaxRadius; let pulseOpacity = 1;
            canvas.clearAnimation = () => { if (animationFrameIdPulse) cancelAnimationFrame(animationFrameIdPulse); animationFrameIdPulse = null; };
            function initPulse(w,h){ pulseMaxRadius = Math.max(w,h) * 0.7; pulseRadius = 0; pulseOpacity = 1;} 
            function drawPulse(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdPulse) cancelAnimationFrame(animationFrameIdPulse); animationFrameIdPulse = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animationFrameIdPulse = requestAnimationFrame(() => drawPulse(canvasEl)); return;}
                if (!pulseMaxRadius) initPulse(w,h); 
                const centerX = w / 2; const centerY = h / 2;
                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                pulseRadius += Math.max(1, pulseMaxRadius * 0.015); 
                pulseOpacity = 1 - (pulseRadius / pulseMaxRadius); 
                if (pulseRadius > pulseMaxRadius || pulseOpacity <= 0) { pulseRadius = 0; pulseOpacity = 1; } 
                if (pulseOpacity > 0) {
                    ctx.strokeStyle = `rgba(${baseRGB}, ${pulseOpacity * 0.8})`;
                    ctx.lineWidth = Math.max(1, Math.min(w,h) * 0.01) * (1 + (1-pulseOpacity)*2) ; 
                    ctx.beginPath(); ctx.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2); ctx.stroke();
                }
                animationFrameIdPulse = requestAnimationFrame(() => drawPulse(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawPulse, initPulse);
            return panel;
        }
        // Network Topology Panel (Nodes and connections on canvas)
        function createNetworkTopologyPanel(areaName) {
            const { panel } = createPanelShell('network-topology', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'network-topology-canvas'; panel.appendChild(canvas);
            let animationFrameIdTopo; let nodes = []; const numNodes = 8; 
            canvas.clearAnimation = () => { if (animationFrameIdTopo) cancelAnimationFrame(animationFrameIdTopo); animationFrameIdTopo = null; };
            function initTopology(w, h) { 
                nodes = [];
                for (let i = 0; i < numNodes; i++) { nodes.push({ x: Math.random() * w * 0.8 + w * 0.1, y: Math.random() * h * 0.8 + h * 0.1, vx: (Math.random() - 0.5) * 0.2, vy: (Math.random() - 0.5) * 0.2, size: Math.random() * (Math.min(w,h) * 0.02) + (Math.min(w,h) * 0.01), connections: [], state: Math.random() < 0.7 ? 'active' : 'inactive' }); }
                for (let i = 0; i < numNodes; i++) { const numConnections = Math.floor(Math.random() * 2) + 1; for (let j = 0; j < numConnections; j++) { const targetNodeIndex = Math.floor(Math.random() * numNodes); if (targetNodeIndex !== i && !nodes[i].connections.includes(targetNodeIndex)) { nodes[i].connections.push(targetNodeIndex); } } }
            }
            function drawTopology(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdTopo) cancelAnimationFrame(animationFrameIdTopo); animationFrameIdTopo = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animationFrameIdTopo = requestAnimationFrame(() => drawTopology(canvasEl)); return;}
                if(nodes.length === 0) initTopology(w,h); 
                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                const primaryColor = `rgb(${baseRGB})`; const inactiveColor = `rgba(${baseRGB}, 0.3)`; const lineColor = `rgba(${baseRGB}, 0.25)`;
                ctx.strokeStyle = lineColor; ctx.lineWidth = Math.max(0.5, Math.min(w,h) * 0.002);
                nodes.forEach((node, idx) => { node.connections.forEach(targetIdx => { if (nodes[targetIdx]) { ctx.beginPath(); ctx.moveTo(node.x, node.y); ctx.lineTo(nodes[targetIdx].x, nodes[targetIdx].y); ctx.stroke(); } }); });
                nodes.forEach(node => {
                    node.x += node.vx; node.y += node.vy; 
                    if (node.x < node.size || node.x > w - node.size) node.vx *= -1; if (node.y < node.size || node.y > h - node.size) node.vy *= -1;
                    if (Math.random() < 0.01) node.state = node.state === 'active' ? 'inactive' : 'active'; 
                    ctx.fillStyle = node.state === 'active' ? primaryColor : inactiveColor;
                    ctx.beginPath(); ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2); ctx.fill();
                    if (node.state === 'active' && Math.random() < 0.1) { ctx.strokeStyle = `rgba(${baseRGB}, 0.5)`; ctx.lineWidth = 1; ctx.stroke(); } 
                });
                animationFrameIdTopo = requestAnimationFrame(() => drawTopology(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawTopology, initTopology);
            return panel;
        }
        // Circular Progress Panel (Multiple circular progress bars on canvas)
        function createCircularProgressPanel(areaName) {
            const { panel } = createPanelShell('circular-progress', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'circular-progress-canvas'; panel.appendChild(canvas);
            let animationFrameIdCircProg; const circles = []; const numCircles = 3;
            canvas.clearAnimation = () => { if (animationFrameIdCircProg) cancelAnimationFrame(animationFrameIdCircProg); animationFrameIdCircProg = null; };
            function initProgress(w, h) { 
                circles.length = 0; const maxRadius = Math.min(w, h) * 0.15;
                for (let i = 0; i < numCircles; i++) { circles.push({ x: (w / (numCircles + 1)) * (i + 1), y: h / 2, radius: Math.random() * (maxRadius * 0.5) + (maxRadius * 0.5), currentValue: Math.random(), targetValue: Math.random(), speed: Math.random() * 0.005 + 0.001 }); }
            }
            function drawProgress(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdCircProg) cancelAnimationFrame(animationFrameIdCircProg); animationFrameIdCircProg = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animationFrameIdCircProg = requestAnimationFrame(() => drawProgress(canvasEl)); return;}
                if(circles.length === 0) initProgress(w,h); 
                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                const primaryColor = `rgb(${baseRGB})`; const trackColor = `rgba(${baseRGB}, 0.2)`; const glowColor = `rgba(${baseRGB}, 0.4)`;
                circles.forEach(circle => {
                    if (Math.abs(circle.currentValue - circle.targetValue) < 0.01) { circle.targetValue = Math.random(); } 
                    circle.currentValue += (circle.targetValue - circle.currentValue) * circle.speed;
                    ctx.strokeStyle = trackColor; ctx.lineWidth = Math.max(2, circle.radius * 0.15);
                    ctx.beginPath(); ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2); ctx.stroke();
                    ctx.strokeStyle = primaryColor; ctx.shadowColor = glowColor; ctx.shadowBlur = 3;
                    ctx.beginPath(); ctx.arc(circle.x, circle.y, circle.radius, -Math.PI / 2, -Math.PI / 2 + (circle.currentValue * Math.PI * 2)); ctx.stroke();
                    ctx.shadowColor = 'transparent';
                });
                animationFrameIdCircProg = requestAnimationFrame(() => drawProgress(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawProgress, initProgress);
            return panel;
        }

        // --- 10 New Panel Types (Total 40) ---

        // 31. Logarithmic Spiral Panel
        function createLogarithmicSpiralPanel(areaName) {
            const { panel } = createPanelShell('log-spiral', areaName);
            const canvas = document.createElement('canvas');
            canvas.className = 'logarithmic-spiral-canvas';
            panel.appendChild(canvas);
            let animationFrameIdSpiral;
            let angle = 0; const a = 0.5, b = 0.2; 
            canvas.clearAnimation = () => { if (animationFrameIdSpiral) cancelAnimationFrame(animationFrameIdSpiral); animationFrameIdSpiral = null; };

            function drawSpiral(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdSpiral) cancelAnimationFrame(animationFrameIdSpiral); animationFrameIdSpiral = null; return; }
                const ctx = canvasEl.getContext('2d');
                const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animationFrameIdSpiral = requestAnimationFrame(() => drawSpiral(canvasEl)); return;}
                const centerX = w / 2, centerY = h / 2;
                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                ctx.strokeStyle = `rgb(${baseRGB})`; ctx.lineWidth = 1.5;
                ctx.beginPath();
                for (let i = 0; i < 200; i++) { 
                    const currentAngle = angle + i * 0.1; const r = a * Math.exp(b * currentAngle);
                    const x = centerX + r * Math.cos(currentAngle); const y = centerY + r * Math.sin(currentAngle);
                    if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                }
                ctx.stroke(); angle += 0.02; 
                animationFrameIdSpiral = requestAnimationFrame(() => drawSpiral(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawSpiral, null);
            return panel;
        }

        // 33. DNA Sequence Panel
        function createDNASequencePanel(areaName) {
            const { panel } = createPanelShell('dna-sequence', areaName);
            const contentDiv = document.createElement('div');
            contentDiv.className = 'dna-sequence-content alien-line'; 
            contentDiv.style.flexWrap = 'nowrap'; 
            contentDiv.style.overflowX = 'hidden'; 
            panel.appendChild(contentDiv);
            let currentSequence = []; 

            const updateSequence = () => {
                if (!panel.isConnected || !contentDiv.clientWidth) return;
                const panelWidth = contentDiv.clientWidth;
                const approxPairWidth = 20; 
                const maxPairs = Math.floor(panelWidth / approxPairWidth);

                const pair = document.createElement('div');
                pair.className = 'dna-pair';
                pair.appendChild(createAlienGlyphSVG(alienGlyphIds[Math.floor(Math.random() * alienGlyphIds.length)]));
                const connector = document.createElement('div');
                connector.className = 'dna-connector';
                pair.appendChild(connector);
                pair.appendChild(createAlienGlyphSVG(alienGlyphIds[Math.floor(Math.random() * alienGlyphIds.length)]));
                contentDiv.appendChild(pair);
                currentSequence.push(pair);

                if (currentSequence.length > maxPairs + 5) { 
                    const oldPair = currentSequence.shift();
                    if (oldPair && oldPair.parentElement === contentDiv) { 
                       contentDiv.removeChild(oldPair);
                    }
                }
                if(currentSequence.length > maxPairs) {
                    contentDiv.style.transform = `translateX(-${(currentSequence.length - maxPairs) * approxPairWidth}px)`;
                } else {
                    contentDiv.style.transform = 'translateX(0px)';
                }
            };
            panel.initContent = updateSequence; 
            panelUpdateIntervals.push(setInterval(updateSequence, 400 + Math.random() * 200));
            return panel;
        }

        // 34. Radar Sweep Panel
        function createRadarSweepPanel(areaName) {
            const { panel } = createPanelShell('radar-sweep', areaName);
            const canvas = document.createElement('canvas');
            canvas.className = 'radar-sweep-canvas';
            panel.appendChild(canvas);
            let animationFrameIdRadar;
            let angle = 0; let blips = []; const numBlips = 8;
            canvas.clearAnimation = () => { if (animationFrameIdRadar) cancelAnimationFrame(animationFrameIdRadar); animationFrameIdRadar = null; };
            function initRadar(w, h) { 
                blips = []; const radius = Math.min(w, h) / 2 * 0.85;
                for (let i = 0; i < numBlips; i++) {
                    blips.push({ r: Math.random() * radius, theta: Math.random() * Math.PI * 2, alpha: 0, life: 0, maxLife: Math.random() * 100 + 50 });
                }
            }
            function drawRadar(canvasEl) {
                if (!canvasEl.isConnected) { if(animationFrameIdRadar) cancelAnimationFrame(animationFrameIdRadar); animationFrameIdRadar = null; return; }
                const ctx = canvasEl.getContext('2d');
                const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animationFrameIdRadar = requestAnimationFrame(() => drawRadar(canvasEl)); return;}
                if(blips.length === 0) initRadar(w,h); 
                const centerX = w / 2, centerY = h / 2; const radius = Math.min(w, h) / 2 * 0.85;
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                ctx.clearRect(0, 0, w, h);
                ctx.strokeStyle = `rgba(${baseRGB}, 0.2)`; ctx.lineWidth = 1;
                [0.25, 0.5, 0.75, 1].forEach(r => { ctx.beginPath(); ctx.arc(centerX, centerY, radius * r, 0, Math.PI * 2); ctx.stroke(); });
                ctx.beginPath(); ctx.moveTo(centerX, centerY - radius); ctx.lineTo(centerX, centerY + radius); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(centerX - radius, centerY); ctx.lineTo(centerX + radius, centerY); ctx.stroke();
                ctx.strokeStyle = `rgba(${baseRGB}, 0.6)`; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(centerX, centerY); ctx.lineTo(centerX + radius * Math.cos(angle), centerY + radius * Math.sin(angle)); ctx.stroke();
                blips.forEach(blip => {
                    if (blip.life > 0) { blip.alpha = (blip.life / blip.maxLife) * 0.8; blip.life--; } 
                    else if (Math.abs(angle - blip.theta) < 0.1 || Math.abs(angle - (blip.theta + Math.PI*2)) < 0.1 || Math.abs(angle - (blip.theta - Math.PI*2)) < 0.1) {
                        if(Math.random() < 0.3) { blip.life = blip.maxLife; blip.alpha = 0.8; } 
                    }
                    if (blip.alpha > 0) {
                        ctx.fillStyle = `rgba(${baseRGB}, ${blip.alpha})`; ctx.beginPath();
                        ctx.arc(centerX + blip.r * Math.cos(blip.theta), centerY + blip.r * Math.sin(blip.theta), 2, 0, Math.PI * 2); ctx.fill();
                    }
                });
                angle = (angle + 0.02) % (Math.PI * 2); 
                animationFrameIdRadar = requestAnimationFrame(() => drawRadar(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawRadar, initRadar);
            return panel;
        }

        // 36. Horizontal Spectrum Panel
        function createHorizontalSpectrumPanel(areaName) {
            const { panel } = createPanelShell('h-spectrum', areaName);
            const canvas = document.createElement('canvas');
            canvas.className = 'horizontal-spectrum-canvas';
            panel.appendChild(canvas);
            let animFrame; const numBars = 10; let barWidths = [];
            canvas.clearAnimation = () => { if (animFrame) cancelAnimationFrame(animFrame); animFrame = null; };
            function initSpectrum(w,h){ barWidths = new Array(numBars).fill(0).map(()=> Math.random() * w * 0.7); }
            function drawSpectrum(canvasEl){
                if (!canvasEl.isConnected) { if(animFrame) cancelAnimationFrame(animFrame); animFrame = null; return; }
                const ctx = canvasEl.getContext('2d');
                const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animFrame = requestAnimationFrame(()=>drawSpectrum(canvasEl)); return;}
                if(barWidths.length === 0 && w > 0) initSpectrum(w,h); 
                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                const barHeight = h / numBars;
                for (let i = 0; i < numBars; i++) {
                    barWidths[i] += (Math.random() - 0.5) * (w * 0.15);
                    barWidths[i] = Math.max(0, Math.min(w * 0.9, barWidths[i] + (Math.random() * (w*0.05) - (w*0.025)) ));
                    if (Math.random() < 0.05) barWidths[i] = Math.random() * w * 0.7; 
                    ctx.fillStyle = `rgba(${baseRGB}, ${0.4 + Math.random() * 0.5})`; 
                    ctx.fillRect(0, i * barHeight + barHeight * 0.1, barWidths[i], barHeight * 0.8); 
                }
                animFrame = requestAnimationFrame(()=>drawSpectrum(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawSpectrum, initSpectrum);
            return panel;
        }

        // 37. Globe Projection Panel
        function createGlobeProjectionPanel(areaName) {
            const { panel } = createPanelShell('globe-proj', areaName);
            const canvas = document.createElement('canvas');
            canvas.className = 'globe-projection-canvas';
            panel.appendChild(canvas);
            let animFrame; let rotationY = 0; const points = []; const numPoints = 20; 
            canvas.clearAnimation = () => { if (animFrame) cancelAnimationFrame(animFrame); animFrame = null; };
            function initGlobe(w,h) { 
                points.length = 0;
                for(let i=0; i<numPoints; i++){ points.push({ lat: (Math.random() - 0.5) * Math.PI, lon: (Math.random() - 0.5) * 2 * Math.PI, blink: Math.random() * 100 }); }
            }
            function drawGlobe(canvasEl){
                if (!canvasEl.isConnected) { if(animFrame) cancelAnimationFrame(animFrame); animFrame = null; return; }
                const ctx = canvasEl.getContext('2d');
                const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animFrame = requestAnimationFrame(()=>drawGlobe(canvasEl)); return;}
                if(points.length === 0 && w > 0 && h > 0) initGlobe(w,h); 
                const centerX = w / 2, centerY = h / 2; const radius = Math.min(w, h) * 0.4;
                ctx.clearRect(0, 0, w, h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                ctx.strokeStyle = `rgba(${baseRGB}, 0.3)`; ctx.lineWidth = 0.5;
                for (let lat = -Math.PI / 2 + Math.PI/10; lat < Math.PI / 2; lat += Math.PI / 10) {
                    ctx.beginPath();
                    for (let lon = -Math.PI; lon <= Math.PI; lon += 0.1) {
                        const x = radius * Math.cos(lat) * Math.cos(lon + rotationY); const z = radius * Math.cos(lat) * Math.sin(lon + rotationY); const y = radius * Math.sin(lat);
                        if (z > -radius*0.3) { 
                            if(lon === -Math.PI) ctx.moveTo(centerX + x, centerY - y); else ctx.lineTo(centerX + x, centerY - y);
                        }
                    }
                    ctx.stroke();
                }
                for (let lon = -Math.PI; lon < Math.PI; lon += Math.PI / 8) {
                    ctx.beginPath();
                    for (let lat = -Math.PI / 2; lat <= Math.PI / 2; lat += 0.1) {
                        const x = radius * Math.cos(lat) * Math.cos(lon + rotationY); const z = radius * Math.cos(lat) * Math.sin(lon + rotationY); const y = radius * Math.sin(lat);
                        if (z > -radius*0.3) { 
                             if(lat === -Math.PI/2) ctx.moveTo(centerX + x, centerY - y); else ctx.lineTo(centerX + x, centerY - y);
                        }
                    }
                    ctx.stroke();
                }
                points.forEach(p => {
                    p.blink--; if(p.blink < 0) p.blink = Math.random() * 200 + 50; 
                    if(p.blink < 20 && p.blink % 4 < 2){ 
                        const x3d = radius * Math.cos(p.lat) * Math.cos(p.lon + rotationY); const z3d = radius * Math.cos(p.lat) * Math.sin(p.lon + rotationY); const y3d = radius * Math.sin(p.lat);
                        if(z3d > 0) { 
                            ctx.fillStyle = `rgba(${baseRGB}, 0.9)`; ctx.beginPath(); ctx.arc(centerX + x3d, centerY - y3d, 1.5, 0, Math.PI*2); ctx.fill();
                        }
                    }
                });
                rotationY += 0.005; 
                animFrame = requestAnimationFrame(()=>drawGlobe(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawGlobe, initGlobe);
            return panel;
        }

        // 38. Data Flow Chart Panel
        function createDataFlowChartPanel(areaName) {
            const { panel } = createPanelShell('flow-chart', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'data-flow-chart-canvas'; panel.appendChild(canvas);
            let animFrame; const nodes = []; const numNodes = 5; const particles = []; const numParticles = 15;
            canvas.clearAnimation = () => { if (animFrame) cancelAnimationFrame(animFrame); animFrame = null; };
            function initChart(w,h){ 
                nodes.length = 0; particles.length = 0;
                for(let i=0; i<numNodes; i++){ nodes.push({x: Math.random()*w*0.8 + w*0.1, y: Math.random()*h*0.8 + h*0.1, w: w*0.1, h: h*0.12}); }
                nodes.sort((a,b) => a.x - b.x); 
                for(let i=0; i<numParticles; i++){ const startNodeIndex = Math.floor(Math.random() * (numNodes -1)); particles.push({ currentNode: startNodeIndex, targetNode: startNodeIndex + 1, progress: Math.random(), speed: 0.01 + Math.random()*0.01 }); }
            }
            function drawChart(canvasEl){
                if (!canvasEl.isConnected) { if(animFrame) cancelAnimationFrame(animFrame); animFrame = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animFrame = requestAnimationFrame(()=>drawChart(canvasEl)); return;}
                if(nodes.length === 0 && w > 0 && h > 0) initChart(w,h); 
                ctx.clearRect(0,0,w,h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                ctx.strokeStyle = `rgba(${baseRGB}, 0.5)`; ctx.fillStyle = `rgba(${baseRGB}, 0.2)`; ctx.lineWidth = 1;
                nodes.forEach(node => { ctx.fillRect(node.x - node.w/2, node.y - node.h/2, node.w, node.h); ctx.strokeRect(node.x - node.w/2, node.y - node.h/2, node.w, node.h); });
                ctx.fillStyle = `rgb(${baseRGB})`;
                particles.forEach(p => {
                    const start = nodes[p.currentNode]; const end = nodes[p.targetNode]; if(!start || !end) return;
                    ctx.beginPath(); ctx.moveTo(start.x, start.y); ctx.lineTo(end.x, end.y); ctx.stroke();
                    const particleX = start.x + (end.x - start.x) * p.progress; const particleY = start.y + (end.y - start.y) * p.progress;
                    ctx.beginPath(); ctx.arc(particleX, particleY, 2.5, 0, Math.PI*2); ctx.fill();
                    p.progress += p.speed;
                    if(p.progress >= 1){ p.progress = 0; p.currentNode = p.targetNode; p.targetNode = (p.targetNode + 1) % numNodes; if(p.targetNode === p.currentNode) p.targetNode = (p.targetNode + 1) % numNodes; } 
                });
                animFrame = requestAnimationFrame(()=>drawChart(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawChart, initChart);
            return panel;
        }

        // 39. Particle Collision Panel
        function createParticleCollisionPanel(areaName) {
            const { panel } = createPanelShell('particle-collision', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'particle-collision-canvas'; panel.appendChild(canvas);
            let animFrame; let particles = []; const numParticles = 25;
            canvas.clearAnimation = () => { if (animFrame) cancelAnimationFrame(animFrame); animFrame = null; };
            function initCollision(w,h){ 
                particles = [];
                for(let i=0; i<numParticles; i++){ particles.push({ x: Math.random()*w, y: Math.random()*h, vx: (Math.random()-0.5)*1.5, vy: (Math.random()-0.5)*1.5, radius: Math.random()*2 + 1.5, life: 100 + Math.random()*100, collided: false }); }
            }
            function drawCollision(canvasEl){
                if (!canvasEl.isConnected) { if(animFrame) cancelAnimationFrame(animFrame); animFrame = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animFrame = requestAnimationFrame(()=>drawCollision(canvasEl)); return;}
                if(particles.length === 0 && w > 0 && h > 0) initCollision(w,h); 
                ctx.clearRect(0,0,w,h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                particles.forEach((p, i) => {
                    p.x += p.vx; p.y += p.vy; p.life--;
                    if(p.x < p.radius || p.x > w - p.radius) p.vx *= -1; if(p.y < p.radius || p.y > h - p.radius) p.vy *= -1;
                    if(p.life <=0){ p.x = Math.random()*w; p.y = Math.random()*h; p.vx = (Math.random()-0.5)*1.5; p.vy = (Math.random()-0.5)*1.5; p.life = 100 + Math.random()*100; p.collided = false; }
                    for(let j = i+1; j < particles.length; j++){
                        const other = particles[j]; const dist = Math.hypot(p.x - other.x, p.y - other.y);
                        if(dist < p.radius + other.radius && !p.collided && !other.collided){ p.collided = true; other.collided = true; p.vx += (Math.random()-0.5)*2; p.vy += (Math.random()-0.5)*2; other.vx += (Math.random()-0.5)*2; other.vy += (Math.random()-0.5)*2; } 
                    }
                    ctx.fillStyle = p.collided ? `rgba(${baseRGB}, 0.9)` : `rgba(${baseRGB}, 0.5)`; 
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2); ctx.fill();
                    p.collided = false; 
                });
                animFrame = requestAnimationFrame(()=>drawCollision(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawCollision, initCollision);
            return panel;
        }

        // --- 10 NEW PANELS (41-50) ---

        // 41. Glyph Constellation Panel
        function createGlyphConstellationPanel(areaName) {
            const { panel } = createPanelShell('glyph-constellation', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'glyph-constellation-canvas'; panel.appendChild(canvas);
            let animFrame; const glyphs = []; const numGlyphs = 12; 
            canvas.clearAnimation = () => { if (animFrame) cancelAnimationFrame(animFrame); animFrame = null; };
            function initConstellation(w,h) { 
                glyphs.length = 0;
                for(let i=0; i<numGlyphs; i++){
                    glyphs.push({
                        id: alienGlyphIds[Math.floor(Math.random() * alienGlyphIds.length)], 
                        x: Math.random() * w, y: Math.random() * h,
                        size: (parseFloat(getComputedStyle(canvas).fontSize) || 16) * (Math.random()*0.4 + 0.8), 
                        alpha: Math.random()*0.5 + 0.3,
                        pulseSpeed: Math.random()*0.02 + 0.005,
                        pulsePhase: Math.random() * Math.PI * 2
                    });
                }
            }
            function drawConstellation(canvasEl){
                if (!canvasEl.isConnected) { if(animFrame) cancelAnimationFrame(animFrame); animFrame = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) { animFrame = requestAnimationFrame(()=>drawConstellation(canvasEl)); return;}
                if(glyphs.length === 0) initConstellation(w,h); 
                ctx.clearRect(0,0,w,h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                ctx.strokeStyle = `rgba(${baseRGB}, 0.05)`; ctx.lineWidth = 0.3;
                for(let i=0; i<glyphs.length; i++){
                    for(let j=i+1; j<glyphs.length; j++){
                        if(Math.random() < 0.03){ 
                            ctx.beginPath(); ctx.moveTo(glyphs[i].x, glyphs[i].y); ctx.lineTo(glyphs[j].x, glyphs[j].y); ctx.stroke();
                        }
                    }
                }
                glyphs.forEach(g => {
                    g.pulsePhase += g.pulseSpeed; 
                    const currentAlpha = g.alpha + Math.sin(g.pulsePhase) * 0.15;
                    ctx.fillStyle = `rgba(${baseRGB}, ${Math.max(0.1, Math.min(1, currentAlpha))})`;
                    ctx.beginPath(); ctx.arc(g.x, g.y, g.size/1.5, 0, Math.PI*2); 
                    ctx.fill();
                });
                animFrame = requestAnimationFrame(()=>drawConstellation(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawConstellation, initConstellation);
            return panel;
        }

        // 42. Data Barcode Panel
        function createDataBarcodePanel(areaName) {
            const { panel } = createPanelShell('data-barcode', areaName);
            const contentDiv = document.createElement('div');
            contentDiv.className = 'data-barcode-content';
            panel.appendChild(contentDiv);
            const numStrips = 4; 
            const estimatedStripHeight = 20; 
            let initialFillDone = false;

            const initOrUpdateBarcodes = () => {
                if (!panel.isConnected) return false;
                if (!contentDiv.clientWidth || !contentDiv.clientHeight) { if(panel.clientHeight > 0) requestAnimationFrame(initOrUpdateBarcodes); return false; }
                if (!initialFillDone || Math.random() < 0.1) { 
                    contentDiv.innerHTML = ''; 
                    const panelWidth = contentDiv.clientWidth;
                    const panelHeight = contentDiv.clientHeight;
                    const maxStrips = Math.max(1, Math.floor(panelHeight / estimatedStripHeight));
                    const actualStrips = Math.min(numStrips, maxStrips);

                    for (let i = 0; i < actualStrips; i++) {
                        const strip = document.createElement('div');
                        strip.className = 'data-barcode-strip alien-line'; 
                        const glyphBaseSize = (parseFloat(getComputedStyle(contentDiv).fontSize) || 16) * 0.50; 
                        const glyphCount = Math.floor(panelWidth / glyphBaseSize) + 5; 

                        for (let j = 0; j < glyphCount; j++) {
                            const glyph = createAlienGlyphSVG(Math.random() < 0.5 ? binaryGlyphZero : binaryGlyphOne);
                            glyph.style.height = `${Math.random() * 0.6 + 0.4}em`; 
                            glyph.style.width = `${glyphBaseSize * (Math.random() * 0.3 + 0.7)}px`; 
                            glyph.style.alignSelf = 'flex-end'; 
                            strip.appendChild(glyph);
                        }
                        contentDiv.appendChild(strip);
                    }
                    initialFillDone = true;
                }
                return true;
            };
            panel.initContent = initOrUpdateBarcodes;
            panelUpdateIntervals.push(setInterval(initOrUpdateBarcodes, 5000 + Math.random() * 3000)); 
            return panel;
        }


        // 43. Bio-Rhythm Panel
        function createBioRhythmPanel(areaName) {
            const { panel } = createPanelShell('bio-rhythm', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'bio-rhythm-canvas'; panel.appendChild(canvas);
            let animFrame; const waves = []; const numWaves = 3;
            canvas.clearAnimation = () => { if (animFrame) cancelAnimationFrame(animFrame); animFrame = null; };
            function initBio(w,h){ 
                waves.length = 0;
                for(let i=0; i<numWaves; i++){
                    waves.push({
                        amplitude: h/ (numWaves * 2.5) * (Math.random()*0.4 + 0.8),
                        frequency: Math.random()*0.05 + 0.02,
                        phase: Math.random() * Math.PI * 2,
                        offsetY: (h / (numWaves + 1)) * (i + 1),
                        colorAlpha: Math.random()*0.3 + 0.5
                    });
                }
            }
            function drawBio(canvasEl){
                if (!canvasEl.isConnected) { if(animFrame) cancelAnimationFrame(animFrame); animFrame = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animFrame = requestAnimationFrame(()=>drawBio(canvasEl)); return;}
                if(waves.length === 0) initBio(w,h); 
                ctx.clearRect(0,0,w,h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                ctx.lineWidth = 1.5;
                waves.forEach(wave => {
                    ctx.strokeStyle = `rgba(${baseRGB}, ${wave.colorAlpha})`;
                    ctx.beginPath();
                    for(let x=0; x<w; x++){ 
                        const y = wave.offsetY + wave.amplitude * Math.sin(x * wave.frequency + wave.phase);
                        if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                    }
                    ctx.stroke();
                    wave.phase += 0.01; 
                });
                animFrame = requestAnimationFrame(()=>drawBio(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawBio, initBio);
            return panel;
        }

        // 44. Hex Grid Panel
        function createHexGridPanel(areaName) {
            const { panel } = createPanelShell('hex-grid', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'hex-grid-canvas'; panel.appendChild(canvas);
            let animFrame; let hexes = []; let hexSize;
            canvas.clearAnimation = () => { if (animFrame) cancelAnimationFrame(animFrame); animFrame = null; };
            function initHex(w,h){ 
                hexes = []; hexSize = Math.min(w,h) / 10; 
                const hexWidth = Math.sqrt(3) * hexSize;
                const hexHeight = 2 * hexSize;
                let q = 0; 
                for(let x = hexWidth/2; x < w + hexWidth; x += hexWidth){
                    let r = 0; 
                    for(let y = hexHeight/2; y < h + hexHeight; y += hexHeight * 3/4){ 
                        const actualX = (q % 2 === 0) ? x : x + hexWidth/2; 
                        if(actualX - hexWidth/2 > w || actualX + hexWidth/2 < 0) continue; 
                        hexes.push({ q, r, x: actualX, y, alpha: Math.random()*0.5 + 0.1 });
                        r++;
                    }
                    q++;
                }
            }
            function drawHex(ctx, x, y, size, fillAlpha, baseRGB) { 
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    ctx.lineTo(x + size * Math.cos(Math.PI/3 * i + Math.PI/6), y + size * Math.sin(Math.PI/3 * i + Math.PI/6));
                }
                ctx.closePath();
                ctx.fillStyle = `rgba(${baseRGB}, ${fillAlpha})`; ctx.fill();
                ctx.strokeStyle = `rgba(${baseRGB}, ${Math.min(1, fillAlpha + 0.2)})`; ctx.stroke();
            }
            function drawHexGrid(canvasEl){
                if (!canvasEl.isConnected) { if(animFrame) cancelAnimationFrame(animFrame); animFrame = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) {animFrame = requestAnimationFrame(()=>drawHexGrid(canvasEl)); return;}
                if(hexes.length === 0 || Math.abs(hexSize - Math.min(w,h)/10) > 2) initHex(w,h); 
                ctx.clearRect(0,0,w,h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                hexes.forEach(hex => {
                    if(Math.random() < 0.002) hex.alpha = Math.random()*0.5 + 0.1; 
                    drawHex(ctx, hex.x, hex.y, hexSize * 0.9, hex.alpha, baseRGB); 
                });
                animFrame = requestAnimationFrame(()=>drawHexGrid(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawHexGrid, initHex);
            return panel;
        }


// --- NEW CUSTOM PANEL: Quantum Entanglement Monitor ---
function createQuantumEntanglementPanel(areaName) {
    const { panel, title } = createPanelShell('quantum-entanglement', areaName);
    const canvas = document.createElement('canvas');
    canvas.className = 'quantum-entanglement-canvas'; // New class for this canvas
    panel.appendChild(canvas);

    let animationFrameId;
    let particlePairs = [];
    const NUM_PAIRS = 3; // Number of entangled pairs
    const PARTICLE_RADIUS = 3;
    const FLASH_DURATION_MAX = 20; // Ticks
    const FLASH_COOLDOWN_MAX = 150; // Ticks

    canvas.clearAnimation = () => {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
    };

    function initQuantumData(w, h, canvasEl) {
        particlePairs = [];
        for (let i = 0; i < NUM_PAIRS; i++) {
            const p1 = {
                x: Math.random() * w, y: Math.random() * h,
                vx: (Math.random() - 0.5) * 0.3, vy: (Math.random() - 0.5) * 0.3,
                isFlashing: false, flashDuration: 0, flashCooldown: Math.floor(Math.random() * FLASH_COOLDOWN_MAX)
            };
            const p2 = {
                x: Math.random() * w, y: Math.random() * h,
                vx: (Math.random() - 0.5) * 0.3, vy: (Math.random() - 0.5) * 0.3,
                isFlashing: false, flashDuration: 0, flashCooldown: p1.flashCooldown // Synchronize initial cooldown
            };
            particlePairs.push({ p1, p2, id: i });
        }
    }

    function drawQuantumEntanglement(canvasEl) {
        if (!canvasEl.isConnected) {
            canvas.clearAnimation();
            return;
        }
        const ctx = canvasEl.getContext('2d');
        const w = canvasEl.width, h = canvasEl.height;

        if (w <= 0 || h <= 0) {
            animationFrameId = requestAnimationFrame(() => drawQuantumEntanglement(canvasEl));
            return;
        }
        if (particlePairs.length === 0 || Math.random() < 0.001) { // Occasional re-init or if empty
             initQuantumData(w,h,canvasEl);
        }


        ctx.clearRect(0, 0, w, h);
        const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
        const primaryColor = `rgb(${baseRGB})`;
        const flashColor = `rgba(${baseRGB}, 0.9)`;
        const normalColor = `rgba(${baseRGB}, 0.5)`;
        const lineColor = `rgba(${baseRGB}, 0.15)`;

        particlePairs.forEach(pair => {
            // Handle flashing logic for the pair
            if (pair.p1.isFlashing) {
                pair.p1.flashDuration--;
                if (pair.p1.flashDuration <= 0) {
                    pair.p1.isFlashing = false;
                    pair.p2.isFlashing = false; // Partner stops flashing
                    pair.p1.flashCooldown = FLASH_COOLDOWN_MAX + Math.floor(Math.random() * 50);
                    pair.p2.flashCooldown = pair.p1.flashCooldown;
                }
            } else {
                pair.p1.flashCooldown--;
                if (pair.p1.flashCooldown <= 0) {
                    if (Math.random() < 0.015) { // Chance to start flashing
                        pair.p1.isFlashing = true;
                        pair.p2.isFlashing = true; // Partner also flashes
                        pair.p1.flashDuration = FLASH_DURATION_MAX;
                        pair.p2.flashDuration = FLASH_DURATION_MAX;
                    } else {
                         // Reset cooldown if no flash
                        pair.p1.flashCooldown = 5 + Math.floor(Math.random() * 20);
                        pair.p2.flashCooldown = pair.p1.flashCooldown;
                    }
                }
            }
             // Update and draw p1
            pair.p1.x += pair.p1.vx; pair.p1.y += pair.p1.vy;
            if (pair.p1.x < PARTICLE_RADIUS || pair.p1.x > w - PARTICLE_RADIUS) pair.p1.vx *= -1;
            if (pair.p1.y < PARTICLE_RADIUS || pair.p1.y > h - PARTICLE_RADIUS) pair.p1.vy *= -1;

            ctx.beginPath();
            ctx.arc(pair.p1.x, pair.p1.y, PARTICLE_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = pair.p1.isFlashing ? flashColor : normalColor;
            if (pair.p1.isFlashing) {
                ctx.shadowColor = `rgba(${baseRGB}, 0.7)`;
                ctx.shadowBlur = 5;
            }
            ctx.fill();
            ctx.shadowBlur = 0;


            // Update and draw p2
            pair.p2.x += pair.p2.vx; pair.p2.y += pair.p2.vy;
            if (pair.p2.x < PARTICLE_RADIUS || pair.p2.x > w - PARTICLE_RADIUS) pair.p2.vx *= -1;
            if (pair.p2.y < PARTICLE_RADIUS || pair.p2.y > h - PARTICLE_RADIUS) pair.p2.vy *= -1;
            
            ctx.beginPath();
            ctx.arc(pair.p2.x, pair.p2.y, PARTICLE_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = pair.p2.isFlashing ? flashColor : normalColor;
             if (pair.p2.isFlashing) {
                ctx.shadowColor = `rgba(${baseRGB}, 0.7)`;
                ctx.shadowBlur = 5;
            }
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw a faint line connecting the pair
            ctx.beginPath();
            ctx.moveTo(pair.p1.x, pair.p1.y);
            ctx.lineTo(pair.p2.x, pair.p2.y);
            ctx.strokeStyle = pair.p1.isFlashing ? `rgba(${baseRGB}, 0.3)` : lineColor;
            ctx.lineWidth = 0.5;
            ctx.stroke();
        });

        animationFrameId = requestAnimationFrame(() => drawQuantumEntanglement(canvasEl));
    }

    panel.initContent = () => {
        if (!panel.isConnected) return;
        initCanvasPanel(panel, canvas, drawQuantumEntanglement, initQuantumData);
    };

    return panel;
}

        // 46. Encrypted Transmission Panel
        function createEncryptedTransmissionPanel(areaName) {
            const { panel } = createPanelShell('enc-transmit', areaName);
            const contentDiv = document.createElement('div');
            contentDiv.className = 'encrypted-transmission-content';
            panel.appendChild(contentDiv);
            const estimatedLineHeight = 14;
            const maxLines = 30; 
            let currentLines = []; 
            let lockInFactor = 0; 
            let initialFillDone = false;

            function attemptFill() {
                if (!panel.isConnected) return false;
                if (!contentDiv.clientWidth || !contentDiv.clientHeight) {
                    if (panel.clientHeight > 0) { requestAnimationFrame(attemptFill); } return false;
                }
                const panelWidth = contentDiv.clientWidth;
                const panelHeight = contentDiv.clientHeight;
                const visibleLines = Math.max(1,Math.floor(panelHeight / estimatedLineHeight));
                 if (!initialFillDone) {
                    currentLines = []; contentDiv.innerHTML = '';
                    for(let i=0; i < Math.min(visibleLines + 5, maxLines); i++){ 
                        const line = generateAlienSVGLine(Math.floor(panelWidth / 8) + 10, panelWidth); 
                        line.style.opacity = 0.3 + Math.random() * 0.3; 
                        contentDiv.appendChild(line);
                        currentLines.push(line);
                    }
                    initialFillDone = true;
                }
                return true;
            }
            const updateTransmission = () => {
                if (!panel.isConnected) return;
                if (!initialFillDone) { if(!attemptFill()) return; } 
                if (!contentDiv.clientWidth) return;
                lockInFactor += 0.01; if(lockInFactor > 1) lockInFactor = 0; 
                currentLines.forEach((line, idx) => {
                    if (Math.random() < 0.1 + lockInFactor * 0.3) { 
                        line.innerHTML = ''; 
                        generateAlienSVGSequence(Math.floor(contentDiv.clientWidth / 8) + 10, line);
                    }
                    line.style.opacity = 0.3 + Math.random() * 0.4 + (idx / currentLines.length < lockInFactor ? 0.3 : 0);
                });
            };
            panel.initContent = attemptFill;
            panelUpdateIntervals.push(setInterval(updateTransmission, 80 + Math.random() * 40)); 
            return panel;
        }

        // 47. Quantum Foam Panel
        function createQuantumFoamPanel(areaName) {
            const { panel } = createPanelShell('qfoam', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'main-display-canvas'; panel.appendChild(canvas); 
            let animFrame; let particles = []; const numParticles = 120; 
            canvas.clearAnimation = () => { if (animFrame) cancelAnimationFrame(animFrame); animFrame = null; };
            function initFoam(w,h){ 
                particles = [];
                for(let i=0; i<numParticles; i++){
                    particles.push({
                        x: Math.random()*w, y: Math.random()*h,
                        vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, 
                        life: Math.random()*30 + 10, 
                        maxLife: 40
                    });
                }
            }
            function drawFoam(canvasEl){
                if (!canvasEl.isConnected) { if(animFrame) cancelAnimationFrame(animFrame); animFrame = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) { animFrame = requestAnimationFrame(()=>drawFoam(canvasEl)); return; }
                if(particles.length === 0) initFoam(w,h); 
                ctx.clearRect(0,0,w,h); 
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                particles.forEach(p => {
                    p.x += p.vx; p.y += p.vy; p.life--;
                    if(p.life <= 0 || p.x < 0 || p.x > w || p.y < 0 || p.y > h){
                        p.x = Math.random()*w; p.y = Math.random()*h;
                        p.vx = (Math.random()-0.5)*3; p.vy = (Math.random()-0.5)*3;
                        p.life = Math.random()*30 + 10;
                    }
                    const alpha = (p.life / p.maxLife) * 0.7; 
                    ctx.fillStyle = `rgba(${baseRGB},${alpha})`;
                    ctx.fillRect(p.x, p.y, 2, 2); 
                });
                animFrame = requestAnimationFrame(()=>drawFoam(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawFoam, initFoam);
            return panel;
        }

        // 48. Navigation Vector Panel
        function createNavigationVectorPanel(areaName) {
            const { panel } = createPanelShell('nav-vector', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'nav-vector-canvas'; panel.appendChild(canvas);
            let animFrame; let vectors = []; const numVectors = 5;
            canvas.clearAnimation = () => { if (animFrame) cancelAnimationFrame(animFrame); animFrame = null; };
            function initVectors(w,h){ 
                vectors = [];
                for(let i=0; i<numVectors; i++){
                    vectors.push({
                        angle: Math.random() * Math.PI * 2,
                        targetAngle: Math.random() * Math.PI * 2,
                        length: Math.min(w,h) * (Math.random()*0.2 + 0.15), 
                        speed: Math.random()*0.01 + 0.005, 
                        alpha: Math.random()*0.4 + 0.4
                    });
                }
            }
            function drawVectors(canvasEl){
                if (!canvasEl.isConnected) { if(animFrame) cancelAnimationFrame(animFrame); animFrame = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) { animFrame = requestAnimationFrame(()=>drawVectors(canvasEl)); return;}
                if(vectors.length === 0) initVectors(w,h); 
                const centerX = w/2, centerY = h/2;
                ctx.clearRect(0,0,w,h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();
                vectors.forEach(v => {
                    if(Math.abs(v.angle - v.targetAngle) < 0.02) v.targetAngle = Math.random() * Math.PI * 2; 
                    v.angle += (v.targetAngle - v.angle) * v.speed;

                    ctx.strokeStyle = `rgba(${baseRGB}, ${v.alpha})`; ctx.lineWidth = 1.5;
                    ctx.beginPath(); ctx.moveTo(centerX, centerY);
                    const endX = centerX + v.length * Math.cos(v.angle);
                    const endY = centerY + v.length * Math.sin(v.angle);
                    ctx.lineTo(endX, endY);
                    const headlen = 5; 
                    ctx.lineTo(endX - headlen * Math.cos(v.angle - Math.PI / 6), endY - headlen * Math.sin(v.angle - Math.PI / 6));
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - headlen * Math.cos(v.angle + Math.PI / 6), endY - headlen * Math.sin(v.angle + Math.PI / 6));
                    ctx.stroke();
                });
                animFrame = requestAnimationFrame(()=>drawVectors(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawVectors, initVectors);
            return panel;
        }

        // 49. Glyph Waterfall Panel
        function createGlyphWaterfallPanel(areaName) {
            const { panel } = createPanelShell('glyph-waterfall', areaName);
            const contentDiv = document.createElement('div');
            contentDiv.className = 'glyph-waterfall-content'; 
            panel.appendChild(contentDiv);
            const numColumns = 5; 

            const initWaterfall = () => {
                if (!panel.isConnected || !contentDiv.clientWidth || !contentDiv.clientHeight) { requestAnimationFrame(initWaterfall); return; }
                contentDiv.innerHTML = ''; 
                for (let i = 0; i < numColumns; i++) {
                    const column = document.createElement('div');
                    column.className = 'glyph-waterfall-column';
                    column.style.animationDelay = `${Math.random() * -5}s`; 
                    const glyphCount = Math.floor(contentDiv.clientHeight / 12) + 5; 
                    for (let j = 0; j < glyphCount; j++) {
                        column.appendChild(createAlienGlyphSVG(alienGlyphIds[Math.floor(Math.random() * alienGlyphIds.length)]));
                    }
                    contentDiv.appendChild(column);
                }
            };
            panel.initContent = initWaterfall;
            panelUpdateIntervals.push(setInterval(() => {
                if(panel.isConnected && Math.random() < 0.1) initWaterfall();
            }, 10000));
            return panel;
        }

        // 50. Energy Core Pulse Panel
        function createEnergyCorePulsePanel(areaName) {
            const { panel } = createPanelShell('core-pulse', areaName);
            const canvas = document.createElement('canvas'); canvas.className = 'energy-core-pulse-canvas'; panel.appendChild(canvas);
            let animFrame; let coreSize = 10; let maxSize; let growing = true;
            const rings = []; 
            canvas.clearAnimation = () => { if (animFrame) cancelAnimationFrame(animFrame); animFrame = null; };
            function initCore(w,h){ maxSize = Math.min(w,h) * 0.15; coreSize = maxSize * 0.2; rings.length = 0; }
            function drawCore(canvasEl){
                if (!canvasEl.isConnected) { if(animFrame) cancelAnimationFrame(animFrame); animFrame = null; return; }
                const ctx = canvasEl.getContext('2d'); const w = canvasEl.width, h = canvasEl.height; if(w <= 0 || h <= 0) { animFrame = requestAnimationFrame(()=>drawCore(canvasEl)); return; }
                if(!maxSize) initCore(w,h); 
                const centerX = w/2, centerY = h/2;
                ctx.clearRect(0,0,w,h);
                const baseRGB = getComputedStyle(document.documentElement).getPropertyValue('--base-phosphor-color-rgb').trim();

                for(let i=rings.length-1; i>=0; i--){
                    const ring = rings[i];
                    ring.radius += 1.5; ring.alpha -= 0.01; 
                    if(ring.alpha <= 0) { rings.splice(i,1); continue; } 
                    ctx.strokeStyle = `rgba(${baseRGB}, ${ring.alpha})`;
                    ctx.lineWidth = ring.width;
                    ctx.beginPath(); ctx.arc(centerX, centerY, ring.radius, 0, Math.PI*2); ctx.stroke();
                }

                if(growing) coreSize += 0.3; else coreSize -=0.3;
                if(coreSize > maxSize) growing = false;
                if(coreSize < maxSize * 0.2) {
                    growing = true;
                    if(Math.random() < 0.3) rings.push({radius: coreSize, alpha: 0.7, width: Math.random()*1.5+0.5}); 
                }
                ctx.fillStyle = `rgba(${baseRGB}, 0.8)`;
                ctx.beginPath(); ctx.arc(centerX, centerY, coreSize, 0, Math.PI*2); ctx.fill();
                ctx.shadowColor = `rgba(${baseRGB}, 0.5)`; ctx.shadowBlur = 10; ctx.fill(); ctx.shadowBlur = 0; 

                animFrame = requestAnimationFrame(()=>drawCore(canvasEl));
            }
            panel.initContent = () => initCanvasPanel(panel, canvas, drawCore, initCore);
            return panel;
        }


        // --- Panel Blueprints (50 types) ---
        const panelBlueprints = [
            // Main display types
            { type: 'main', func: createAbstractDataGridPanel, name: 'AbstractGrid' }, 
            { type: 'main', func: createSchematicPanel, name: 'Schematic' },
            { type: 'main', func: createOrbitalPathPanel, name: 'OrbitalPath' }, 
            { type: 'main', func: createTargetingReticulePanel, name: 'TargetReticule' },
            { type: 'main', func: createStarmapPanel, name: 'Starmap' }, 
            { type: 'main', func: createNetworkTopologyPanel, name: 'NetworkTopology' },
            { type: 'main', func: createCircularProgressPanel, name: 'CircularProgress' }, 
            { type: 'main', func: createRadarSweepPanel, name: 'RadarSweep' },
            { type: 'main', func: createGlobeProjectionPanel, name: 'GlobeProjection' }, 
            { type: 'main', func: createParticleCollisionPanel, name: 'ParticleCollision' },
            { type: 'main', func: createGlyphConstellationPanel, name: 'GlyphConstellation'}, 
            { type: 'main', func: createBioRhythmPanel, name: 'BioRhythm'},
            { type: 'main', func: createHexGridPanel, name: 'HexGrid'}, 
            { type: 'main', func: createQuantumFoamPanel, name: 'QuantumFoam'}, 
            { type: 'main', func: createEnergyCorePulsePanel, name: 'EnergyCorePulse'},

            // Auxiliary types
            { type: 'aux', func: createStatusPanel, name: 'Status' }, 
            { type: 'aux', func: createDataStreamPanel, name: 'DataStream' },
            { type: 'aux', func: createCommsLogPanel, name: 'CommsLog' }, 
            { type: 'aux', func: createAlertPanel, name: 'Alert' }, 
            { type: 'aux', func: createSignalBarsPanel, name: 'SignalBars' }, 
            { type: 'aux', func: createTargetListPanel, name: 'TargetList'},
            { type: 'aux', func: createDiagnosticsPanel, name: 'Diagnostics'}, 
            { type: 'aux', func: createWaveformPanel, name: 'Waveform'},
            { type: 'aux', func: createNumericReadoutPanel, name: 'Numeric'}, 
            { type: 'aux', func: createButtonSwitchPanel, name: 'Buttons'},
            { type: 'aux', func: createGaugePanel, name: 'Gauge'}, 
            { type: 'aux', func: createCodeScrollPanel, name: 'CodeScroll'},
            { type: 'aux', func: createHeatmapPanel, name: 'Heatmap'}, 
            { type: 'aux', func: createSystemTreePanel, name: 'SystemTree'},
            { type: 'aux', func: createKeypadPanel, name: 'Keypad'}, 
            { type: 'aux', func: createFrequencySpectrumPanel, name: 'FreqSpectrum' },
            { type: 'aux', func: createSystemLogPanel, name: 'SystemLog' },
            { type: 'aux', func: createEnergyFlowPanel, name: 'EnergyFlow' }, 
            { type: 'aux', func: createDataPacketPanel, name: 'DataPackets' },
            { type: 'aux', func: createSecurityAccessPanel, name: 'SecurityAccess' }, 
            { type: 'aux', func: createPulseWavePanel, name: 'PulseWave' },
            { type: 'aux', func: createArtifactScannerPanel, name: 'ArtifactScanner' },
            { type: 'aux', func: createLogarithmicSpiralPanel, name: 'LogSpiral' },
            { type: 'aux', func: createSubspaceAnomaliesPanel, name: 'SubspaceAnomalies' },
            { type: 'aux', func: createDNASequencePanel, name: 'DNASequence' },
            { type: 'aux', func: createHorizontalSpectrumPanel, name: 'HSpectrum' },
            { type: 'aux', func: createDataFlowChartPanel, name: 'DataFlowChart' }, 
            { type: 'aux', func: createCommsLogPanel, name: 'EncryptedText' }, 
            { type: 'aux', func: createDataBarcodePanel, name: 'DataBarcode'}, 
            { type: 'aux', func: createEncryptedTransmissionPanel, name: 'EncryptedTransmission'}, 
            { type: 'aux', func: createNavigationVectorPanel, name: 'NavVector'},
            { type: 'aux', func: createGlyphWaterfallPanel, name: 'GlyphWaterfall'},
    { type: 'aux', func: createPlasmaInsulatorFieldPanel, name: 'PlasmaField' }, 
    { type: 'aux', func: createQuantumEntanglementPanel, name: 'QuantumMonitor' }, 
    { type: 'aux', func: createSystemLogPanel, name: 'SystemLog' }
        ];


        // --- Main Dashboard Building Logic (with 50 layouts) ---
        function buildRandomDashboard() {
            if (isBuildingDashboard) {
                return; 
            }
            isBuildingDashboard = true; 
            dashboardRoot.style.visibility = 'hidden'; 

            try {
                dashboardRoot.innerHTML = ''; 
                
                panelUpdateIntervals.forEach(intervalId => clearInterval(intervalId));
                panelUpdateIntervals.length = 0; 
                globalAlertPanelRef = null;

                document.querySelectorAll('canvas').forEach(canvas => {
                    if (typeof canvas.clearAnimation === 'function') {
                        canvas.clearAnimation();
                    }
                });

                const layoutType = Math.floor(Math.random() * 50); 
                let gridTemplateAreas, gridTemplateColumns, gridTemplateRows;

                const allPanelBlueprints = [...panelBlueprints];
                for (let i = allPanelBlueprints.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allPanelBlueprints[i], allPanelBlueprints[j]] = [allPanelBlueprints[j], allPanelBlueprints[i]];
                }

                let availableMainPanels = allPanelBlueprints.filter(p => p.type === 'main');
                let availableAuxPanels = allPanelBlueprints.filter(p => p.type === 'aux');
                const alertBlueprint = panelBlueprints.find(p => p.name === 'Alert');
                if (alertBlueprint && !availableAuxPanels.some(p => p.name === 'Alert') && !availableMainPanels.some(p => p.name === 'Alert')) {
                    availableAuxPanels.push(alertBlueprint); 
                }
                for (let i = availableAuxPanels.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [availableAuxPanels[i], availableAuxPanels[j]] = [availableAuxPanels[j], availableAuxPanels[i]];
                }


                let auxPanelCounter = 0;
                let mainPanelCounter = 0;
                let alertPanelUsed = false;

                function getNextPanel(preferredType = 'aux', specificName = null) {
                    if (specificName === 'Alert' && alertPanelUsed) { 
                        preferredType = 'aux'; 
                        specificName = null;
                    }

                    if (specificName) {
                        let specificBlueprint = availableMainPanels.find(p => p.name === specificName);
                        if (specificBlueprint) {
                            if (specificName === 'Alert') alertPanelUsed = true;
                            if (specificName !== 'Alert') availableMainPanels = availableMainPanels.filter(p => p.name !== specificName);
                            return specificBlueprint;
                        }
                        specificBlueprint = availableAuxPanels.find(p => p.name === specificName);
                         if (specificBlueprint) {
                            if (specificName === 'Alert') alertPanelUsed = true;
                            if (specificName !== 'Alert') availableAuxPanels = availableAuxPanels.filter(p => p.name !== specificName);
                            return specificBlueprint;
                        }
                    }

                    if (preferredType === 'main' && availableMainPanels.length > 0) {
                        const panelBp = availableMainPanels[mainPanelCounter % availableMainPanels.length];
                         if (panelBp.name === 'Alert') {
                            if (alertPanelUsed) { mainPanelCounter++; return getNextPanel('main');} 
                            alertPanelUsed = true;
                        }
                        mainPanelCounter++; return panelBp;
                    }
                    if (availableAuxPanels.length > 0) {
                        const panelBp = availableAuxPanels[auxPanelCounter % availableAuxPanels.length];
                        if (panelBp.name === 'Alert') {
                            if (alertPanelUsed) { auxPanelCounter++; return getNextPanel('aux'); } 
                            alertPanelUsed = true;
                        }
                        auxPanelCounter++; return panelBp;
                    }
                    if (preferredType === 'main' && availableAuxPanels.length > 0) return getNextPanel('aux'); 
                    if (preferredType === 'aux' && availableMainPanels.length > 0) return getNextPanel('main');

                    return panelBlueprints[Math.floor(Math.random() * panelBlueprints.length)];
                }


                // --- Layout Definitions (0-49) ---
                if (layoutType === 0) {
                    gridTemplateColumns = "1fr 2fr 1fr"; gridTemplateRows = "1fr 1fr 1fr";
                    gridTemplateAreas = `"aux1 main aux2" "aux3 main aux4" "aux5 main aux6"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('main'));
                    ['aux1', 'aux2', 'aux3', 'aux4', 'aux5', 'aux6'].forEach(area => { dashboardRoot.appendChild(getNextPanel('aux', area === 'aux2' && !alertPanelUsed ? 'Alert' : null).func(area)); });
                } else if (layoutType === 1) {
                    const numRows = Math.random() < 0.5 ? 2 : 3; gridTemplateColumns = "1fr 1fr"; gridTemplateRows = `repeat(${numRows}, 1fr)`;
                    let areas = []; for(let r=1; r<=numRows; r++) { areas.push(`"p${r}c1 p${r}c2"`); }
                    gridTemplateAreas = areas.join('\n'); let mainPanelPlaced = false;
                    for(let r=1; r<=numRows; r++) { for(let c=1; c<=2; c++) {
                        let pb = (!mainPanelPlaced && r === 1 && c === 1 && Math.random() < 0.7) ? (mainPanelPlaced=true, getNextPanel('main')) : getNextPanel('aux', !alertPanelUsed && r === numRows && c === 2 ? 'Alert' : null);
                        dashboardRoot.appendChild(pb.func(`p${r}c${c}`));
                    }}
                } else if (layoutType === 2) {
                    const numPanels = Math.floor(Math.random() * 2) + 4; gridTemplateColumns = "1fr"; gridTemplateRows = `repeat(${numPanels}, 1fr)`;
                    let areas = []; for(let i=1; i<=numPanels; i++) { areas.push(`"panel${i}"`); }
                    gridTemplateAreas = areas.join('\n'); let mainPanelPlaced = false;
                    for(let i=1; i<=numPanels; i++) {
                         let pb = (!mainPanelPlaced && i === 1 && Math.random() < 0.8) ? (mainPanelPlaced=true, getNextPanel('main')) : getNextPanel('aux', !alertPanelUsed && i === numPanels ? 'Alert' : null);
                         dashboardRoot.appendChild(pb.func(`panel${i}`));
                    }
                } else if (layoutType === 3) {
                    gridTemplateColumns = "2fr 1fr 1fr"; gridTemplateRows = "1fr 1fr 2fr";
                    gridTemplateAreas = `"main main aux1" "main main aux2" "aux3 aux4 aux5"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('main')); dashboardRoot.appendChild(getNextPanel('aux').func('aux1'));
                    dashboardRoot.appendChild(getNextPanel('aux', !alertPanelUsed ? 'Alert' : null).func('aux2')); dashboardRoot.appendChild(getNextPanel('aux').func('aux3'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux4')); dashboardRoot.appendChild(getNextPanel('aux').func('aux5'));
                } else if (layoutType === 4) {
                    gridTemplateColumns = "1fr 2fr 1fr"; gridTemplateRows = "1fr 2fr 1fr";
                    gridTemplateAreas = `"aux1 main aux2" "aux3 main aux4" "aux5 auxAlert aux6"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux1')); dashboardRoot.appendChild(getNextPanel('main').func('main'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux2')); dashboardRoot.appendChild(getNextPanel('aux').func('aux3'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux4')); dashboardRoot.appendChild(getNextPanel('aux').func('aux5'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('auxAlert')); dashboardRoot.appendChild(getNextPanel('aux').func('aux6'));
                } else if (layoutType === 5) {
                    gridTemplateColumns = "1fr 1fr 1fr 1fr"; gridTemplateRows = "repeat(3, 1fr)";
                    gridTemplateAreas = `"p1 p2 p2 p3" "p4 p4 p5 p3" "p6 p7 p5 pAlert"`;
                    const areas = ['p1', 'p2', 'p3', 'p4', 'p5', 'p6', 'p7', 'pAlert'];
                    areas.forEach(area => { dashboardRoot.appendChild(getNextPanel(area.startsWith('p2') || area.startsWith('p4') || area.startsWith('p5') ? 'main' : 'aux', area === 'pAlert' && !alertPanelUsed ? 'Alert' : null).func(area)); });
                } else if (layoutType === 6) {
                    gridTemplateColumns = "1.5fr 1fr 1fr 1.5fr"; gridTemplateRows = "2fr 1fr";
                    gridTemplateAreas = `"tall1 short1 short2 tall2" "tall1 short3 shortAlert tall2"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('tall1')); dashboardRoot.appendChild(getNextPanel('aux').func('short1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('short2')); dashboardRoot.appendChild(getNextPanel('main').func('tall2'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('short3')); dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('shortAlert'));
                } else if (layoutType === 7) {
                    gridTemplateColumns = "1fr 2fr 1fr"; gridTemplateRows = "1fr 2fr";
                    gridTemplateAreas = `"top1 top1 topAlert" "side main main"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('top1')); dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('topAlert'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('side')); dashboardRoot.appendChild(getNextPanel('main').func('main'));
                } else if (layoutType === 8) {
                    gridTemplateColumns = "1fr 3fr 1fr"; gridTemplateRows = "1fr 1fr 1fr";
                    gridTemplateAreas = `"stripL1 center stripR1" "stripL2 center stripR2" "stripLAlert center stripR3"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('stripL1')); dashboardRoot.appendChild(getNextPanel('main').func('center'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('stripR1')); dashboardRoot.appendChild(getNextPanel('aux').func('stripL2'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('stripR2'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('stripLAlert'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('stripR3'));
                } else if (layoutType === 9) {
                    gridTemplateColumns = "1fr 1fr"; gridTemplateRows = "1fr 2fr 1fr";
                    gridTemplateAreas = `"band1A band1B" "band2_full band2_full" "band3A bandAlert"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('band1A')); dashboardRoot.appendChild(getNextPanel('aux').func('band1B'));
                    dashboardRoot.appendChild(getNextPanel('main').func('band2_full')); dashboardRoot.appendChild(getNextPanel('aux').func('band3A'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('bandAlert'));
                } else if (layoutType === 10) {
                    gridTemplateColumns = "1fr 1.5fr 1fr"; gridTemplateRows = "1.5fr 1fr 1.5fr";
                    gridTemplateAreas = `"a b b" "a c d" "e eAlert d"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('a')); dashboardRoot.appendChild(getNextPanel('main').func('b'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('c')); dashboardRoot.appendChild(getNextPanel('main').func('d'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('e')); dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('eAlert'));
                } else if (layoutType === 11) {
                    gridTemplateColumns = "1fr 2.5fr 1fr"; gridTemplateRows = "1fr 2.5fr 1fr";
                    gridTemplateAreas = `"tl top tr" "left main right" "bl bottom brAlert"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('tl')); dashboardRoot.appendChild(getNextPanel('aux').func('top'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('tr')); dashboardRoot.appendChild(getNextPanel('aux').func('left'));
                    dashboardRoot.appendChild(getNextPanel('main').func('main')); dashboardRoot.appendChild(getNextPanel('aux').func('right'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('bl')); dashboardRoot.appendChild(getNextPanel('aux').func('bottom'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('brAlert'));
                } else if (layoutType === 12) {
                    gridTemplateColumns = "1fr 1fr 1fr"; gridTemplateRows = "1fr 1.5fr 1fr";
                    gridTemplateAreas = `"s1 s1 s2" "s3 s4 s2" "s3 sAlert s5"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('s1')); dashboardRoot.appendChild(getNextPanel('main').func('s2'));
                    dashboardRoot.appendChild(getNextPanel('main').func('s3')); dashboardRoot.appendChild(getNextPanel('aux').func('s4'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('sAlert')); dashboardRoot.appendChild(getNextPanel('aux').func('s5'));
                } else if (layoutType === 13) {
                    gridTemplateColumns = "1fr 2fr 1fr"; gridTemplateRows = "1fr 2fr";
                    gridTemplateAreas = `"aux1 main aux2" "aux3 main aux4"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux1')); dashboardRoot.appendChild(getNextPanel('main').func('main'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux2')); dashboardRoot.appendChild(getNextPanel('aux').func('aux3'));
                    dashboardRoot.appendChild(getNextPanel('aux', !alertPanelUsed ? 'Alert' : null).func('aux4'));
                } else if (layoutType === 14) {
                    gridTemplateColumns = "1fr 3fr 1fr"; gridTemplateRows = "1fr";
                    gridTemplateAreas = `"auxL main auxR"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxL')); dashboardRoot.appendChild(getNextPanel('main').func('main'));
                    dashboardRoot.appendChild(getNextPanel('aux', !alertPanelUsed ? 'Alert' : null).func('auxR'));
                } else if (layoutType === 15) {
                    gridTemplateColumns = "1fr"; gridTemplateRows = "1fr 3fr 1fr";
                    gridTemplateAreas = `"auxT" "main" "auxB"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxT')); dashboardRoot.appendChild(getNextPanel('main').func('main'));
                    dashboardRoot.appendChild(getNextPanel('aux', !alertPanelUsed ? 'Alert' : null).func('auxB'));
                } else if (layoutType === 16) {
                    gridTemplateColumns = "1fr 1fr 1fr"; gridTemplateRows = "1fr 1fr";
                    gridTemplateAreas = `"aux1 main main" "main main aux2"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux1')); dashboardRoot.appendChild(getNextPanel('main').func('main'));
                    dashboardRoot.appendChild(getNextPanel('aux', !alertPanelUsed ? 'Alert' : null).func('aux2'));
                } else if (layoutType === 17) {
                    gridTemplateColumns = "1fr 1fr 1fr"; gridTemplateRows = "1fr 1fr";
                    gridTemplateAreas = `"main main aux1" "aux2 main main"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('main')); dashboardRoot.appendChild(getNextPanel('aux').func('aux1'));
                    dashboardRoot.appendChild(getNextPanel('aux', !alertPanelUsed ? 'Alert' : null).func('aux2'));
                } else if (layoutType === 18) {
                    gridTemplateColumns = "1fr 3fr 1fr"; gridTemplateRows = "1fr 3fr 1fr";
                    gridTemplateAreas = `"topL topM topR" "midL main midR" "botL botM botAlert"`;
                    ['topL', 'topM', 'topR', 'midL', 'midR', 'botL', 'botM'].forEach(area => { dashboardRoot.appendChild(getNextPanel('aux').func(area)); });
                    dashboardRoot.appendChild(getNextPanel('main').func('main')); dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('botAlert'));
                } else if (layoutType === 19) {
                    gridTemplateColumns = "2fr 1fr 2fr"; gridTemplateRows = "2fr 1fr 2fr";
                    gridTemplateAreas = `"mainTL auxT mainTR" "auxL auxC auxR" "mainBL auxB mainBR"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('mainTL')); dashboardRoot.appendChild(getNextPanel('aux').func('auxT'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainTR')); dashboardRoot.appendChild(getNextPanel('aux').func('auxL'));
                    dashboardRoot.appendChild(getNextPanel('aux', !alertPanelUsed ? 'Alert' : null).func('auxC')); dashboardRoot.appendChild(getNextPanel('aux').func('auxR'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainBL')); dashboardRoot.appendChild(getNextPanel('aux').func('auxB'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainBR'));
                } else if (layoutType === 20) {
                    gridTemplateColumns = "1fr 1fr 1fr"; gridTemplateRows = "1fr 0.5fr 1fr";
                    gridTemplateAreas = `"leftCol midColUp rightCol" "leftCol midColMid rightCol" "leftColAlert midColBot rightColAlert"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('leftCol')); dashboardRoot.appendChild(getNextPanel('aux').func('midColUp'));
                    dashboardRoot.appendChild(getNextPanel('main').func('rightCol')); dashboardRoot.appendChild(getNextPanel('aux').func('midColMid'));
                    dashboardRoot.appendChild(getNextPanel('aux', !alertPanelUsed ? 'Alert' : null).func('leftColAlert')); dashboardRoot.appendChild(getNextPanel('aux').func('midColBot'));
                    dashboardRoot.appendChild(getNextPanel('aux', !alertPanelUsed && Math.random() < 0.5 ? 'Alert' : null).func('rightColAlert'));
                } else if (layoutType === 21) {
                    gridTemplateColumns = "1fr 1.5fr 1fr"; gridTemplateRows = "1fr 1.5fr 1fr";
                    gridTemplateAreas = `"aux1 mainV aux2" "mainH mainH mainH" "aux3 mainV auxAlert"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux1')); dashboardRoot.appendChild(getNextPanel('main').func('mainV'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux2')); dashboardRoot.appendChild(getNextPanel('main').func('mainH'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux3')); dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('auxAlert'));
                } else if (layoutType === 22) {
                    gridTemplateColumns = "2fr 2fr"; gridTemplateRows = "1fr 1fr 1fr";
                    gridTemplateAreas = `"mainL aux1" "mainL aux2" "mainL auxAlert"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('mainL')); dashboardRoot.appendChild(getNextPanel('aux').func('aux1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux2')); dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('auxAlert'));
                } else if (layoutType === 23) {
                    gridTemplateColumns = "1fr 1fr 1fr"; gridTemplateRows = "1fr 2fr 1fr";
                    gridTemplateAreas = `"auxT1 auxT2 auxT3" "main main main" "auxB1 auxAlert auxB2"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxT1')); dashboardRoot.appendChild(getNextPanel('aux').func('auxT2'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxT3')); dashboardRoot.appendChild(getNextPanel('main').func('main'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxB1')); dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('auxAlert'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxB2'));
                } else if (layoutType === 24) {
                    gridTemplateColumns = "1fr 1fr 1fr 1fr"; gridTemplateRows = "1fr 1fr 1fr 1fr";
                    gridTemplateAreas = `"a b c d" "e main main f" "g main main h" "i j k alert"`;
                    ['a','b','c','d','e','f','g','h','i','j','k'].forEach(area => { dashboardRoot.appendChild(getNextPanel('aux').func(area)); });
                    dashboardRoot.appendChild(getNextPanel('main').func('main')); dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('alert'));
                } else if (layoutType === 25) {
                    gridTemplateColumns = "1fr 2fr 1fr"; gridTemplateRows = "1fr 1fr 2fr";
                    gridTemplateAreas = `"aux1 main main" "aux2 main main" "aux3 aux4 auxAlert"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux1')); dashboardRoot.appendChild(getNextPanel('main').func('main'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux2')); dashboardRoot.appendChild(getNextPanel('aux').func('aux3'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux4')); dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('auxAlert'));
                } else if (layoutType === 26) {
                    gridTemplateColumns = "1fr 2fr"; gridTemplateRows = "1fr 1fr 1fr 1fr";
                    gridTemplateAreas = `"side main1" "side main2" "side aux1" "side auxAlert"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('side')); dashboardRoot.appendChild(getNextPanel('main').func('main1'));
                    dashboardRoot.appendChild(getNextPanel('main').func('main2')); dashboardRoot.appendChild(getNextPanel('aux').func('aux1'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('auxAlert'));
                } else if (layoutType === 27) {
                    gridTemplateColumns = "1fr 1fr 1fr 1fr"; gridTemplateRows = "1fr 2fr";
                    gridTemplateAreas = `"top top top top" "col1 col2 col3 colAlert"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('top')); dashboardRoot.appendChild(getNextPanel('aux').func('col1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('col2')); dashboardRoot.appendChild(getNextPanel('aux').func('col3'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('colAlert'));
                } else if (layoutType === 28) {
                    gridTemplateColumns = "1fr 1fr 1fr"; gridTemplateRows = "1fr 1fr 1fr";
                    gridTemplateAreas = `"p1 main1 p2" "main2 p3 main3" "p4 mainAlert p5"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('p1')); dashboardRoot.appendChild(getNextPanel('main').func('main1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('p2')); dashboardRoot.appendChild(getNextPanel('main').func('main2'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('p3')); dashboardRoot.appendChild(getNextPanel('main').func('main3'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('p4')); dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('mainAlert'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('p5'));
                }
                else if (layoutType === 29) { 
                    gridTemplateColumns = "1fr 1fr"; gridTemplateRows = "1fr 1fr";
                    gridTemplateAreas = `
                        "main1 main2"
                        "main3 alert"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('main1'));
                    dashboardRoot.appendChild(getNextPanel('main').func('main2'));
                    dashboardRoot.appendChild(getNextPanel('main').func('main3'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('alert'));
                }
                else if (layoutType === 30) { 
                    gridTemplateColumns = "1fr 2fr 1fr"; gridTemplateRows = "2fr 1fr";
                    gridTemplateAreas = `"leftM main rightM" "leftM bottomR rightM"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('leftM'));
                    dashboardRoot.appendChild(getNextPanel('main').func('main'));
                    dashboardRoot.appendChild(getNextPanel('main').func('rightM'));
                    dashboardRoot.appendChild(getNextPanel('aux', !alertPanelUsed ? 'Alert' : null).func('bottomR'));
                } else if (layoutType === 31) { 
                    gridTemplateColumns = "1fr 1.5fr 1fr 1.5fr"; gridTemplateRows = "1fr 1fr";
                    gridTemplateAreas = `"c1a c2a c3a c4a" "c1b c2b c3b c4Alert"`;
                    ['c1a', 'c2a', 'c3a', 'c4a', 'c1b', 'c2b', 'c3b'].forEach(area => {
                        dashboardRoot.appendChild(getNextPanel(area.includes('2') || area.includes('4a') ? 'main' : 'aux').func(area));
                    });
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('c4Alert'));
                } else if (layoutType === 32) { 
                    gridTemplateColumns = "1fr 1fr 1fr"; gridTemplateRows = "2.5fr 1fr";
                    gridTemplateAreas = `"mainTop mainTop mainTop" "auxB1 auxB2 auxAlert"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('mainTop'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxB1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxB2'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('auxAlert'));
                } else if (layoutType === 33) { 
                    gridTemplateColumns = "2fr 2fr 1fr"; gridTemplateRows = "1fr 1fr";
                    gridTemplateAreas = `"main1 main2 auxS1" "main1 main2 auxAlert"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('main1'));
                    dashboardRoot.appendChild(getNextPanel('main').func('main2'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxS1'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('auxAlert'));
                } else if (layoutType === 34) { 
                    gridTemplateColumns = "repeat(4, 1fr)"; gridTemplateRows = "repeat(3, 1fr)";
                    let areasStr = "";
                    for(let r=0; r<3; r++){ areasStr += `"${Array.from({length:4}, (_,c)=>`sm${r}${c}`).join(" ")}" `;}
                    gridTemplateAreas = areasStr.trim();
                    for(let r=0; r<3; r++){ for(let c=0; c<4; c++){
                        dashboardRoot.appendChild(getNextPanel('aux', r===2 && c===3 && !alertPanelUsed ? 'Alert' : null).func(`sm${r}${c}`));
                    }}
                } else if (layoutType === 35) { 
                    gridTemplateColumns = "1.5fr 1fr 1.5fr"; gridTemplateRows = "1.5fr 1fr 1.5fr";
                    gridTemplateAreas = `"mainTL topM mainTR" "leftM centerM rightM" "mainBL botM mainBR"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('mainTL'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('topM'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainTR'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('leftM'));
                    dashboardRoot.appendChild(getNextPanel('aux', !alertPanelUsed ? 'Alert' : null).func('centerM'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('rightM'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainBL'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('botM'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainBR'));
                } else if (layoutType === 36) { 
                    gridTemplateColumns = "1fr 0.8fr 1fr 0.8fr 1fr"; gridTemplateRows = "1fr";
                    gridTemplateAreas = `"slice1 div1 slice2 div2 sliceAlert"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('slice1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('div1'));
                    dashboardRoot.appendChild(getNextPanel('main').func('slice2'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('div2'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('sliceAlert'));
                } else if (layoutType === 37) { 
                    gridTemplateColumns = "1fr"; gridTemplateRows = "1fr 0.8fr 1fr 0.8fr 1fr";
                    gridTemplateAreas = `"sliceA" "divA" "sliceB" "divB" "sliceAlert"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('sliceA'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('divA'));
                    dashboardRoot.appendChild(getNextPanel('main').func('sliceB'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('divB'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('sliceAlert'));
                } else if (layoutType === 38) { 
                    gridTemplateColumns = "1fr 1fr 1fr 1fr"; gridTemplateRows = "1fr 2.5fr";
                    gridTemplateAreas = `"auxT1 auxT2 auxT3 auxT4" "mainB mainB mainB mainAlert"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxT1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxT2'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxT3'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxT4'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainB'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('mainAlert'));
                } else if (layoutType === 39) { 
                    gridTemplateColumns = "3fr 1fr"; gridTemplateRows = "1fr 1fr 1fr";
                    gridTemplateAreas = `"main aux1" "main aux2" "main auxAlert"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('main'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux2'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('auxAlert'));
                }
                else if (layoutType === 40) { 
                    gridTemplateColumns = "1fr 2fr 1fr 2fr"; gridTemplateRows = "2fr 1fr 2fr";
                    gridTemplateAreas = `
                        "mainL1 mainL1 aux1 mainR1"
                        "aux2 auxC1 auxC2 mainR1"
                        "mainL2 aux3 aux4 mainR1"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('mainL1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux1'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainR1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux2'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxC1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('auxC2'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainL2'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux3'));
                    dashboardRoot.appendChild(getNextPanel('aux', !alertPanelUsed ? 'Alert' : null).func('aux4'));
                } else if (layoutType === 41) { 
                    gridTemplateColumns = "1fr 2fr 1fr"; gridTemplateRows = "1fr 2fr 1fr";
                    gridTemplateAreas = `
                        "cornerTL mainH1 cornerTR"
                        "mainV1 mainC mainV2"
                        "cornerBL mainH2 cornerBRAlert"`;
                    dashboardRoot.appendChild(getNextPanel('aux').func('cornerTL'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainH1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('cornerTR'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainV1'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainC'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainV2'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('cornerBL'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainH2'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('cornerBRAlert'));
                } else if (layoutType === 42) { 
                    gridTemplateColumns = "1fr 1fr 1fr"; 
                    gridTemplateRows = "1fr 1fr"; 
                    gridTemplateAreas = `
                        "lt lm lb" 
                        "rt rm rb"`;
                    ['lt', 'lm', 'lb', 'rt', 'rm', 'rb'].forEach((area, index) => {
                        dashboardRoot.appendChild(getNextPanel(index < 2 ? 'main' : 'aux', area === 'rb' && !alertPanelUsed ? 'Alert' : null).func(area));
                    });
                } else if (layoutType === 43) { 
                    gridTemplateColumns = "1fr 2fr 1.5fr"; gridTemplateRows = "1fr 0.5fr 1fr 0.5fr 1fr";
                    gridTemplateAreas = `
                        "colA band1 colC"
                        "colA div1 colC"
                        "colA mainB colC"
                        "colA div2 colC"
                        "colA band2 colAlert"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('colA'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('band1'));
                    dashboardRoot.appendChild(getNextPanel('main').func('colC'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('div1'));
                    dashboardRoot.appendChild(getNextPanel('main').func('mainB'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('div2'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('band2'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('colAlert'));
                } else if (layoutType === 44) { 
                    gridTemplateColumns = "1fr 1fr 1fr 1fr 1fr"; gridTemplateRows = "1fr 2fr 1fr";
                    gridTemplateAreas = `
                        "h1 h2 h3 h4 h5"
                        "m1 m2 mainM m3 m4"
                        "f1 f2 fAlert f3 f4"`;
                    ['h1','h2','h3','h4','h5','m1','m2','m3','m4','f1','f2','f3','f4'].forEach(area => {
                        dashboardRoot.appendChild(getNextPanel('aux').func(area));
                    });
                    dashboardRoot.appendChild(getNextPanel('main').func('mainM'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('fAlert'));
                } else if (layoutType === 45) { 
                    gridTemplateColumns = "1fr 1fr 1fr 1fr"; gridTemplateRows = "1fr 1fr 1fr";
                    gridTemplateAreas = `
                        "blockA blockA blockB aux1"
                        "aux2 blockC blockB blockD"
                        "aux3 blockC blockAlert blockD"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('blockA'));
                    dashboardRoot.appendChild(getNextPanel('main').func('blockB'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux2'));
                    dashboardRoot.appendChild(getNextPanel('main').func('blockC'));
                    dashboardRoot.appendChild(getNextPanel('main').func('blockD'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('aux3'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('blockAlert'));
                } else if (layoutType === 46) { 
                    gridTemplateColumns = "1fr 1fr 1fr"; gridTemplateRows = "2.5fr 1fr 1fr";
                    gridTemplateAreas = `
                        "mainTop mainTop mainTop"
                        "bottomL1 bottomM1 bottomR1"
                        "bottomL2 bottomAlert bottomR2"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('mainTop'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('bottomL1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('bottomM1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('bottomR1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('bottomL2'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('bottomAlert'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('bottomR2'));
                } else if (layoutType === 47) { 
                    gridTemplateColumns = "2.5fr 1fr 1fr"; gridTemplateRows = "1fr 1fr 1fr";
                    gridTemplateAreas = `
                        "mainL rightT1 rightT2"
                        "mainL rightM1 rightM2"
                        "mainL rightBAlert rightB2"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('mainL'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('rightT1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('rightT2'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('rightM1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('rightM2'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('rightBAlert'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('rightB2'));
                } else if (layoutType === 48) { 
                    gridTemplateColumns = "1fr 2fr 1fr"; gridTemplateRows = "1fr 2fr 1fr";
                    gridTemplateAreas = `
                        "auxTL auxTM auxTR"
                        "auxML main auxMR"
                        "auxBL auxBM auxBRAlert"`;
                    ['auxTL','auxTM','auxTR','auxML','auxMR','auxBL','auxBM'].forEach(area => {
                        dashboardRoot.appendChild(getNextPanel('aux').func(area));
                    });
                    dashboardRoot.appendChild(getNextPanel('main').func('main'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('auxBRAlert'));
                } else if (layoutType === 49) { 
                    gridTemplateColumns = "1fr 1fr 0.5fr 1fr 1fr"; gridTemplateRows = "1fr 0.5fr 1fr 1fr";
                    gridTemplateAreas = `
                        "m1 m1 div1 a1 a2"
                        "m1 m1 div1 a3 a4"
                        "b1 b2 main b3 b4"
                        "c1 c2 alert c3 c4"`;
                    dashboardRoot.appendChild(getNextPanel('main').func('m1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('div1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('a1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('a2'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('a3'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('a4'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('b1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('b2'));
                    dashboardRoot.appendChild(getNextPanel('main').func('main'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('b3'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('b4'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('c1'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('c2'));
                    dashboardRoot.appendChild(getNextPanel('aux', 'Alert').func('alert'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('c3'));
                    dashboardRoot.appendChild(getNextPanel('aux').func('c4'));
                }


                dashboardRoot.style.gridTemplateAreas = gridTemplateAreas;
                dashboardRoot.style.gridTemplateColumns = gridTemplateColumns;
                dashboardRoot.style.gridTemplateRows = gridTemplateRows;

                const panelElements = Array.from(document.querySelectorAll('.panel'));
                const initPromises = panelElements.map(panelEl => {
                    return new Promise(resolve => {
                        requestAnimationFrame(() => {
                            if (panelEl.isConnected) {
                                const titleEl = panelEl.querySelector('.panel-title');
                                if (titleEl && titleEl.childNodes.length === 0) {
                                    generateAlienSVGSequence(Math.floor(Math.random() * 10) + 20, titleEl);
                                }
                                if (typeof panelEl.initContent === 'function') {
                                    panelEl.initContent();
                                }
                            }
                            resolve(); 
                        });
                    });
                });

                Promise.all(initPromises).then(() => {
                    dashboardRoot.style.visibility = 'visible';
                });

            } finally {
                requestAnimationFrame(() => {
                    isBuildingDashboard = false;
                });
            }
        }

        // --- Event Listeners ---
        window.addEventListener('load', () => {
            applyRandomMonochromeTheme();
            buildRandomDashboard(); 
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'r' || event.key === 'R') { 
                applyRandomMonochromeTheme();
                buildRandomDashboard();
            }
        });

    </script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script>
      const screenshotBtn = document.getElementById('screenshotButton');

      function freezeCanvases(root) {
        const replacements = [];
        root.querySelectorAll('canvas').forEach(c => {
          try {
            const img = new Image();
            img.src = c.toDataURL();
            img.width = c.width;
            img.height = c.height;
            c.style.display = 'none';
            c.parentNode.insertBefore(img, c);
            replacements.push({ canvas: c, img });
          } catch (e) {}
        });
        return () => {
          replacements.forEach(({ canvas, img }) => {
            img.remove();
            canvas.style.display = '';
          });
        };
      }

      screenshotBtn.addEventListener('click', () => {
        screenshotBtn.style.display = 'none';
        const root = document.getElementById('dashboardRoot');
        const restore = freezeCanvases(root);
        html2canvas(root, { useCORS: true, backgroundColor: null, scale: 1 })
          .then(canvas => {
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = 'alien-dashboard.png';
            link.click();
            restore();
            screenshotBtn.style.display = 'flex';
          })
          .catch(() => {
            restore();
            screenshotBtn.style.display = 'flex';
          });
      });
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1CQ4D3VQ3L');
</script>
</body>
</html>
